/** \mainpage MOOCHO: Multi-functional Object-Oriented arCHitecture for Optimization

\section moocho_outline_sec Outline

<ul>
<li>\ref mooch_intro_sec
<li>\ref moocho_math_overview_sec
\if BUILD_HTML <li>\ref moocho_pdf_version_sec \endif \if BUILD_LATEX <li>\ref moocho_html_version_sec \endif
<li>\ref moocho_quickstart_sec
  <ul>
  <li>\ref moocho_quickstart_solve_driver_sec
  <li>\ref moocho_quickstart_solving_sec
    <ul>
    <li>\ref moocho_quickstart_input_linear_solver_input_params_sec
    <li>\ref moocho_quickstart_moocho_input_options_sec
    <li>\ref moocho_quickstart_solver_output_sec
      <ul>
      <li> \ref moocho_console_output_sec "Console output" 
           (\ref moocho_console_sample_out_grp "output")
      <li> \ref moocho_algo_output_sec "Algorithm Configuration Output" 
           (\ref moocho_algo_sample_out_grp "MoochoAlgo.out")
      <li> \ref moocho_summary_output_sec "Algorithm Summary and Timing Output" 
           (\ref moocho_summary_sample_out_grp "MoochoSummary.out")
      <li> \ref moocho_journal_output_sec "Algorithm Journal Output" 
           (\ref moocho_journal_sample_out_grp "MoochoJournal.out")
      </ul>
    <li>\ref moocho_quickstart_algo_interrupt_sec
    </ul>
  </ul>
<li>\ref moocho_nlps_sec
  <ul>
  <li>\ref moocho_explicit_nlps_sec
  <li>\ref moocho_simulation_constrained_nlps_sec
  </ul>
<li>\ref moocho_dependencies_sec
<li>\ref moocho_internal_links_sec
<li>\ref moocho_browse_sec
<li>\ref moocho_links_sec
</ul>

\section mooch_intro_sec Introduction

MOOCHO (Multifunctional Object-Oriented arCHitecture for Optimization) is a <a
href="http://trilinos.sandia.gov">Trilinos</a> package written in C++
designed to solve large-scale, equality and inequality nonlinearly
constrained, non-convex optimization problems (i.e. nonlinear programs) using
reduced-space successive quadratic programming (SQP) methods.  The most
general form of the optimization problem that can be solved is:

\f[
\begin{array}{rcl}
\mbox{minimize}   &  & f(x) \\
\mbox{subject to} &  & c(x) = 0 \\
                  &  & x_L \leq x    \leq x_U
\end{array}
\f]

where \f$x\in\Re^n\f$ the vector of optimization variables,
\f$f(x)\in\Re^n\rightarrow\Re\f$ is the nonlinear scalar objective function,
\f$c(x)=0\f$ (where \f$c(x)\in\Re^n\rightarrow\Re^m\f$) are the nonlinear
constraints, and \f$x_L\f$ and \f$x_U\f$ are the upper and lower bounds on the
variables.  The current algorithms in MOOCHO are well suited to solving
optimization problems with massive numbers of unknown variables and equations
but few so-called degrees of optimization freedom (i.e. the degrees of freedom
= the number of variables minus the number of equality constraints =
\f$n-m\f$).  Various line-search based globalization methods are available,
including exact penalty functions and a form of the filter method.  Many of
the algorithms in MOOCHO are provably locally and globally convergent for a
wide class of problems in theory but in practice the behavior and the
performance of the algorithms varies greatly from problem to problem.

MOOCHO was initially developed to solve general sparse optimization problems
where there is no clear distinction between state variables and optimization
parameters.  For these types of problems a serial sparse direct solver must be
used (i.e. MA28) to find a square basis that is needed for the variable
reduction decompositions that are current supported.

More recently, MOOCHO has been interfaced through <tt><a
href="../../../thyra/doc/html/index.html">Thyra</a></tt> and the
<tt>Thyra::ModelEvaluator</tt> interface to address very large-scale,
massively parallel, simulation-constrained optimization problems that take the
form:

\f[
\begin{array}{rcl}
\mbox{minimize}   &  & f(x_D,x_I) \\
\mbox{subject to} &  & c(x_D,x_I) = 0 \\
                  &  & x_{D,L} \leq x_D \leq x_{D,U} \\
                  &  & x_{I,L} \leq x_I \leq x_{I,U}
\end{array}
\f]

where \f$x_D\in\Re^{m}\f$ are the "dependent" state variables,
\f$x_I\in\Re^{n-m}\f$ are the "independent" optimization parameters and
\f$c(x_D,x_I)=0\f$ are the discrete nonlinear state simulation equations.
Here the state Jacobian \f$\frac{\partial c}{\partial x_D}\f$ must be square
and nonsingular and the partitioning of \f$x=\left[\begin{array}{cc} x_D^T &
x_I^T \end{array}\right]^T\f$ into state variables \f$x_D\f$ and optimization
variables \f$x_I\f$ must be known <em>a priori</em> and this partitioning can
not change during a solve.  Warning, the <tt>Thyra::ModelEvaluator</tt>
interface uses a overlapping and inconsistent set set of names for the
variables and the problem functions than the names used by MOOCHO.  All of the
functionality needed for MOOCHO to solve a simulation-constrained optimization
problem can be specified through sub-classing the
<tt>Thyra::ModelEvaluator</tt> interface, and related <tt>%Thyra</tt>
interfaces.  Epetra-based applications can instead implement the
<tt>EpetraExt::ModelEvaluator</tt> interface and never need to work with
%Thyra directly except in trivial and transparent ways.

For simulation-constrained optimization problems, MOOCHO can utilize the full
power of the massively parallel iterative linear solvers and preconditioners
available in Trilinos through %Thyra through the <tt><a
href="../../../stratimikos/doc/html/index.html">Stratimikos</a></tt> package
by just flipping a few switches in a parameter list.  These include all of the
direct solves in <a href="../../../amesos/doc/html/index.html">Amesos</a>, the
preconditioners in <a href="../../../ifpack/doc/html/index.html">Ifpack</a>
and <a href="../../../ml/doc/html/index.html">ML</a>, and the iterative Krylov
solvers in <a href="../../../aztecoo/doc/html/index.html">AztecOO</a> and <a
href="../../../belos/doc/html/index.html">Belos</a> (Belos is not being
released but is available in the development version of Trilinos).  For small
to moderate numbers of optimization parameters, the only bottleneck to
parallel scalability is the linear solver used to solve linear systems
involving the state Jacobian \f$\frac{\partial c}{\partial x_D}\f$.  The
reduced-space SQP algorithms in MOOCHO itself achieve extremely good parallel
scalability.  The parallel scalability of the linear solvers is controlled by
the simulation application and the Trilinos linear solvers and preconditioners
themselves.  Typically, the parallel scalability of the linear solve is
limited by the preconditioner as the problem is partitioned to more and more
processes.

MOOCHO also includes a minimally invasive mode for reduced-space SQP where the
simulator application only needs to compute the objective and constraint
functions \f$f(x_D,x_I)\in\Re^{n}\rightarrow\Re\f$ and
\f$c(x_D,x_I)\in\Re^{n}\rightarrow\Re^{m}\f$ and solve only forward linear
systems involving \f$\frac{\partial c}{\partial x_D}\f$.  All other
derivatives can be approximated with directional finite differences but any
exact derivatives that can be computed by the application are happily accepted
and fully utilized by MOOCHO through the <tt>Thyra::ModelEvaluator</tt>
interface.

\section moocho_math_overview_sec MOOCHO Mathematical Overview Document

A more detailed mathematical overview of nonlinear programming and the
algorithms that MOOCHO implements are described in the document <a
href="MoochoOverview.pdf">A Mathematical and High-Level Overview of
MOOCHO</a>.  This document also defines the mapping of mathematical notation
to C++ identifiers used by MOOCHO.  User's should at least browse this
document in order to understand the basics of what MOOCHO is doing.

\if BUILD_HTML

\section moocho_pdf_version_sec PDF Version of this Document

An PDF version of his doxygen collection can be found <a
href="./MoochoReference.pdf">here</a> for people who want to print this
documentation out and read hard copy.

\endif

\if BUILD_LATEX

\section moocho_html_version_sec Hyper-linked HTML version of this Document

The doxygen-generated hyper-linked version of his document can be found at the
Trilinos website under the link to MOOCHO.

\endif

\section moocho_quickstart_sec MOOCHO Quickstart

In order to get started using MOOCHO to solve your NLPs you must first build
MOOCHO as part of Trilinos and install it.

<b>Quickstart Outline</b>
  <ul>
  <li>\ref moocho_quickstart_solve_driver_sec
  <li>\ref moocho_quickstart_solving_sec
    <ul>
    <li>\ref moocho_quickstart_input_linear_solver_input_params_sec
    <li>\ref moocho_quickstart_moocho_input_options_sec
    <li>\ref moocho_quickstart_solver_output_sec
      <ul>
      <li> \ref moocho_console_output_sec "Console output"
           (\ref moocho_console_sample_out_grp "output")
      <li> \ref moocho_algo_output_sec "Algorithm Configuration Output"
           (\ref moocho_algo_sample_out_grp "MoochoAlgo.out")
      <li> \ref moocho_summary_output_sec "Algorithm Summary and Timing Output"
           (\ref moocho_summary_sample_out_grp "MoochoSummary.out")
      <li> \ref moocho_journal_output_sec "Algorithm Journal Output"
           (\ref moocho_journal_sample_out_grp "MoochoJournal.out")
      </ul>
    <li>\ref moocho_quickstart_algo_interrupt_sec
    </ul>
  </ul>

<!-- Note: The above list is mirrored in the initial outline above! -->

\subsection moocho_quickstart_solve_driver_sec Setting up a driver program to call a MOOCHO solver

Once an NLP is defined, a driver program must be constructed to setup a MOOCHO
solver and configure it given options set by the user.  When building a driver
program to solve an NLP based on an
<tt>NLPInterfacePack::NLPSerialPreprocessExplJac</tt> subclass object, one
should directly use the "Facade" solver class
<tt>MoochoPack::MoochoSolver</tt> (see <tt><a
href="./NLPWBCounterExampleMain_8cpp-example.html">
NLPWBCounterExampleMain.cpp</a></tt>).  However, when using an NLP based on a
<tt>Thyra::ModelEvaluator</tt> object, then the more specialized "Facade"
solver class <tt>MoochoPack::MoochoThyraSolver</tt> should be used
(see <tt><a href="./NLPThyraEpetraModelEval4DOptMain_8cpp-example.html">
NLPThyraEpetraModelEval4DOptMain.cpp</a></tt>).  The class
<tt>MoochoPack::MoochoThyraSolver</tt> just uses
<tt>MoochoPack::MoochoSolver</tt> internally for the main solve but provides a
great deal of extra functionality to set initial guesses (also from an input
file) and wrap the model evaluator object with various "Decorator" skins and
to capture and return the final solution.

\subsection moocho_quickstart_solving_sec Running MOOCHO to Solve Optimization Problems

Once an NLP is defined and a driver program is in place (see the above driver
programs), then MOOCHO can be run to try to solve the optimization problem.
Most of the options that affect MOOCHO (and the Trilinos linear solvers
accessed through Stratimikos) can be read in from various input files or
specified entirely on the command line.  The diver programs shown above show
examples of how to setup a Techos::CommandLineProcessor object to accept a
number of different command-line arguments that can be used to read in MOOCHO
and Trilinos linear solver options.  For example, consider the simple driver
program <tt><a href="./NLPThyraEpetraModelEval4DOptMain_8cpp-example.html">
NLPThyraEpetraModelEval4DOptMain.cpp</a></tt>.  This example shows the use of
both MOOCHO options and Stratimikos linear solver options.

Here are the command-line arguments that the program <tt><a
href="./NLPThyraEpetraModelEval4DOptMain_8cpp-example.html">
NLPThyraEpetraModelEval4DOptMain.cpp</a></tt> accepts:

\verbinclude NLPThyraEpetraModelEval4DOpt.help.out

Below, the various types of input and output are described.  Input
parameters/options are separated into linear solver parameters for
%Stratimikos and algorithm options for %MOOCHO.

\subsubsection moocho_quickstart_input_linear_solver_input_params_sec Linear solver input parameters for Stratimikos (Thyra models only)

When using a <tt>%Thyra::ModelEvaluator</tt>-based NLP, the linear solver
options for inverting the basis of the equality constraints are read in
through a <tt>Teuchos::ParameterList</tt> object which is accepted through the
%Stratimikos class <tt>Stratimikos::DefaultLinearSolverBuilder</tt>.  When a
<tt>MoochoPack::MoochoThyraSolver</tt> object is used to build a
driver program, it can add options to the
<tt>Teuchos::CommandLineProcessor</tt> object through the function
<tt>Stratimikos::DefaultLinearSolverBuilder::setupCLP()</tt> (see <tt><a
href="./NLPThyraEpetraModelEval4DOptMain_8cpp-example.html">
NLPThyraEpetraModelEval4DOptMain.cpp</a></tt>).  This adds the command-line arguments
<tt>--linear-solver-params-file</tt> and <tt>--extra-linear-solver-params</tt>
 which are used to read in parameters for the Stratimikos-wrapped linear
solvers in XML format.

The linear solver parameters file is specified in XML and the list of all of
the valid options can be found in the documentation for the class
<tt>Stratimikos::DefaultLinearSolverBuilder</tt> itself.

An example of a linear solver options input file that specifies the use of the
%Amesos solver <tt>Amesos_Klu</tt> is shown below:

\verbinclude _amesos.klu.xml

The XML input for the linear solver parameters can be read from a file using
the <tt>--linear-solver-params-file</tt> argument and/or from the command-line
itself using the <tt>--extra-linear-solver-params</tt> argument.  Note that
any parameters specified by the <tt>--extra-linear-solver-params</tt> argument
will append and overwrite those read in from the file specified by the
<tt>--linear-solver-params-file</tt> argument.  If the argument
<tt>--linear-solver-params-file</tt> is missing, then a set of internal
options is looked for instead.

\subsubsection moocho_quickstart_moocho_input_options_sec MOOCHO input options

The input for the MOOCHO options currently uses a completely different system
than for linear solver parameters used by Stratimikos.  The class
<tt>OptionsFromStreamPack::OptionsFromStream</tt> is used to read in MOOCHO
options from a text string (or a file) and is used to represent an options
data base that is used by MOOCHO.  The function
<tt>MoochoPack::MoochoSolver::setup_commandline_processor()</tt> can be used
to set the command-line arguments <tt>--moocho-options-file</tt> and
<tt>--moocho-extra-options</tt> to read in MOOCHO options.  The format of the
options file and a listing, with documentation, of all of the valid MOOCHO
options is shown \ref Moocho_all_opts "here".

An example of an options file showing some of the common options that a user
might want to set is shown below:

\verbinclude Moocho.sample.opt

<!-- Note, the above options file is tested automatically by
moocho/example/generate-sample-output.pl.stub.in! -->

For more detailed documentation on what each of these options mean and more,
see the full listing of the options \ref Moocho_all_documentation_opts "here".

The command-line argument <tt>--moocho-options-file</tt> is used to read in an
set of MOOCHO options from a file using the format shown above.  If the
argument <tt>--moocho-options-file</tt> is missing, then a file with the name
"Moocho.opt" is looked for in the current directory.  If this file is not
found, then a warning is printed and a default set of options are used.  The
user is warned to check that their opinions file was actually read and that it
will be ignored if it is not found!

The argument <tt>--moocho-extra-options</tt> can be used to specify MOOCHO
options directly on the command line in a slightly more terse format than the
format of a MOOCHO options file.  For example, the command-line equivalent to
a subset of the options set in the above example MOOCHO options file is:

\verbatim

--moocho-extra-options="\
  NLPSolverClientInterface{max_iter=20,max_run_time=2.0,opt_tol=1e-2,feas_tol=1e-7\
    ,journal_output_level= PRINT_ALGORITHM_STEPS\
    ,null_space_journal_output_level=PRINT_ITERATION_QUANTITIES\
    ,journal_print_digits=10,calc_conditioning=true,calc_matrix_norms=true\
    ,calc_matrix_info_null_space_only=true}\
  :DecompositionSystemStateStepBuilderStd{\
    null_space_matrix=EXPLICIT,range_space_matrix=ORTHOGONAL}\
  :NLPAlgoConfigMamaJama{quasi_newton=BFGS,line_search_method=FILTER}"
\endverbatim

<!-- ToDo: Find an automated way to test the above commandline options! -->

The options specified in the <tt>--moocho-extra-options</tt> argument will
append and override those read in from a MOOCHO input file specified by the
<tt>--moocho-options-file</tt> argument.

\subsubsection moocho_quickstart_solver_output_sec MOOCHO algorithm output

When a MOOCHO optimization algorithm is run, by default, several different
types of output are generated.  By default, output is sent to the console
(i.e. standard out) and to three different files: <tt>MoochoSummary.out</tt>,
<tt>MoochoAlgo.out</tt>, and <tt>MoochoJournal.out</tt>.  These four output
streams provide different types of information about the MOOCHO algorithm.

To demonstrate the output files, here we show example output generated by the
example program <tt><a
href="./NLPThyraEpetraModelEval4DOptMain_8cpp-example.html">
NLPThyraEpetraModelEval4DOptMain.cpp</a></tt>.  This example is used since it
is fairly simple but can be used to generate more interesting output files.
The output from running MOOCHO on a <tt>Thyra::ModelEvaluator</tt>-based NLP
looks very similar to running on one based on the more general NLP interface.

The example program <tt>NLPThyraEpetraModelEval4DOpt.exe</tt> when run with
the command-line arguments:

\verbinclude ExampleNLPBanded.cmndline.input.txt

with the above sample <tt>\ref Moocho_sample_opt "Moocho.opt"</tt> options
file, creates the output:

<ul>
<li> \ref moocho_console_output_sec "Console output"
     (\ref moocho_console_sample_out_grp "output")
<li> \ref moocho_algo_output_sec "Algorithm Configuration Output"
     (\ref moocho_algo_sample_out_grp "MoochoAlgo.out")
<li> \ref moocho_summary_output_sec "Algorithm Summary and Timing Output"
     (\ref moocho_summary_sample_out_grp "MoochoSummary.out")
<li> \ref moocho_journal_output_sec "Algorithm Journal Output"
     (\ref moocho_journal_sample_out_grp "MoochoJournal.out")
</ul>

<!-- Note: The above list is mirrored in the initial outline and quickstart
outlines above! -->

Each of these different types of output are described below and the major
types of output that are included in each output stream are discussed.  The
purpose of this treatment is to familiarize the user with the contents of
these outputs and to give hints of where to look for a certain types of
information.

Before going into the details of each individual type of output, first a few
general comments are in order.  First, at the top of every output file (except
for the console output) a header is included that briefly describes the
general purpose of the output file.  This header is followed by an echo of the
options that where read into the
<tt>OptionsFromStreamPack::OptionsFromSteam</tt> object.  These options
include those set in the input file <tt>Moocho.opt</tt> or by some other means
(e.g.~in the executable or on the command line) as described above.  The
purpose of echoing the options in each file is to help record what setting
were used to produce the output in the file.  Of course the output is also
influenced by other factors (e.g. other command-line options, properties of
the specific NLP being solved etc.) and therefore these options do not
determine the complete behavior of the software.

<b>Console Output (\ref moocho_console_sample_out_grp "output")</b> \anchor moocho_console_output_sec

Console outputting is generated by a default
<tt>IterationPack::AlgorithmTracker</tt> subclass subclass object of type
<tt>MoochoPack::MoochoTrackerConsoleStd</tt>.  This output is designed to
approximately fit in an 80 character wide console.  Here is the output that is
generated for this example program:

\verbinclude ExampleNLPBanded.sample.out

Above, one of the the first things printed is the size of the NLP where
<tt>n</tt> is the total number of variables, <tt>m</tt> is the total number of
equality constraints and <tt>nz</tt> is the number of nonzeros in the Jacobian
\f$\nabla c\f$ (<tt>Gc</tt>).  Note that for a simulation-constrained
optimization problem that <tt>nz</tt> will not give any useful information
since this is not available through the %Thyra interfaces.

Following the global dimensions of the problem, a table containing summary
information for each rSQP iteration is printed in real time.  Each column in
this table has the following meaning:

<ul>

<li> <b><tt>k</tt></b> : The SQP iteration counter.  This count starts from
zero so the total number of SQP iterations is one plus the final <tt>k</tt>.

<li> <b><tt>f</tt></b> : The value of the objective function \f$f(x)\f$
(possibly scaled) at current estimate of the solution \f$x_k\f$

<li> <b><tt>||c||s</tt></b> : The scaled residual of the norm of the equality
constraints \f$c(x)\f$ at current estimate of the solution \f$x_k\f$.  The
scaling is determined by the convergence check (see the step
"CheckConvergence" in \ref moocho_algo_sample_out_grp "MoochoAlgo.out" and \ref
moocho_journal_sample_out_grp "MoochoJournal.out") and this value is actually
equal to the iteration quantity <tt>feas_kkt_err</tt> (see the file \ref
moocho_algo_sample_out_grp "MoochoAlgo.out").  This is the error that is
compared to the tolerance <tt>feas_tol</tt> in the convergence check (which is
equal to the option <tt>NLPSolverClientInterface{feas_tol}</tt>).  The
unscaled constraint norm can be viewed in the more detailed iteration summary
table printed in the file \ref moocho_summary_sample_out_grp
"MoochoSummary.out".

<li> <b><tt>||rGL||s</tt></b> : The scaled norm of the reduced gradient of the
Lagrangian \f$Z^T \nabla_x L\f$ at current estimate of the solution \f$x_k\f$.
The scaling is determined by the convergence check (see the step
"CheckConvergence" in \ref moocho_algo_sample_out_grp "MoochoAlgo.out" and \ref
moocho_journal_sample_out_grp "MoochoJournal.out") and this value is actually
equal to the iteration quantity <tt>opt_kkt_err</tt> (see the file \ref
moocho_algo_sample_out_grp "MoochoAlgo.out").  This is the error that is
compared to the tolerance <tt>opt_tol</tt> in the convergence check (which is
equal to the option <tt>NLPSolverClientInterface{opt_tol}</tt>).  The unscaled
norm can be viewed in the more detailed summary table printed in the file \ref
moocho_summary_sample_out_grp "MoochoSummary.out".

<li> <b><tt>QN</tt></b> : This field indicates whether a quasi-Newton update
of the reduced Hessian was performed or not.  The following are the possible
values:
<ul>
<li> <b><tt>IN</tt></b> : Reinitialized (usually to identity \f$I\f$)
<li> <b><tt>DU</tt></b> : A dampened update was performed
<li> <b><tt>UP</tt></b> : An undamped update was performed
<li> <b><tt>SK</tt></b> : The update was skipped on purpose
<li> <b><tt>IS</tt></b> : The update was skipped because it was indefinite
</ul>

<li> <b><tt>#act</tt></b> : Number of active constraints in the QP subproblem.
This field only has meaning for an active-set algorithms.  For interior-point
algorithms, this will just equal the number of bounded variables and does not
provide any useful information.  For problems without any bounds or inequality
constraints, this column is not shown.

<li> <b><tt>||Ypy||2</tt></b> : The \f$||.||_2\f$ norm of the quasi-normal
contribution \f$(Y p_y)_k\f$.  This norm gives a sense of how large the
feasibility steps are.

<li> <b><tt>||Zpz||2</tt></b> : The \f$||.||_2\f$ norm of the tangential
contribution \f$(Z p_z)_k\f$.  This norm gives a sense of how large the
optimality steps are.

<li> <b><tt>||d||inf</tt></b> : The \f$||.||_{\infty}\f$ norm of the total
step \f$d_k = (Y p_y)_k + (Z p_z)_k\f$.  This norm gives a sense of how large
the full SQP steps are in \f$x\f$.

<li> <b><tt>alpha</tt></b> : The step length taken along \f$x_{k+1} = x_k +
\alpha d_k\f$.  A step length of \f$\alpha = 0\f$ represents a major event in
the algorithm such as a line search failure followed by the selection of a new
basis or a QP failure followed by a reinitialization of the reduced Hessian.
A small number for \f$\alpha\f$ indicates that many backtracking line search
iterations where required and is an indication that the computed search
direction \f$d_k\f$ is of poor quality.  A value of <tt>alpha=1.0</tt> usually
indicates that the algorithm is taking full spaces and may be performing well.

<li> <b><tt>time(s)</tt></b> : The total wall-clock time consumed by the
algorithm to that point.  By differencing the times between iterations, one
can compute the amount of time taken for each iteration.  See the more
detailed timing output in the file \ref moocho_summary_sample_out_grp
"MoochoSummary.out".

</ul>

After the iteration summary is printed, the total wall-clock time is given in
<tt>Total time</tt>.  This is the wall-clock time that is consumed from the
time that the <tt>MoochoPack::MoochoTrackerConsoleStd</tt> object is first
initialized up until the time that the final state of the algorithm is
reported.  Therefore, this wall-clock time may contain more than just the
execution time of the algorithm proper.  For more detailed built-in timings,
see the table at the end of the file \ref moocho_summary_sample_out_grp
"MoochoSummary.out".

Following the total runtime, the total number of function and gradient
evaluations is given for the objective and the constraints.  Note that if
finite difference testing is turned on, then many extra evaluations will be
performed and this will inflate these counters.

<b>Algorithm Configuration Output (\ref moocho_algo_sample_out_grp "MoochoAlgo.out")</b> \anchor moocho_algo_output_sec

In addition to output the console, MOOCHO will also write a file called \ref
moocho_algo_sample_out_grp "MoochoAlgo.out" by default that gives information
about what MOOCHO algorithm is configured and what logic went into its
configuration.  This file is too long to be shown here.  This file provides
the road map for determining what iteration quantities are being used by the
algorithm, what the algorithmic steps are, and what the logic of the algorithm
is using a shorthand, Matlab-like, notation.  This file is the first place to
go when trying to figure out what a MOOCHO algorithm is doing and is critical
to understand the \ref moocho_journal_sample_out_grp "MoochoJournal.out" file.

Many of the options specified in the options file are shown in the printed
algorithm.  The user can therefore study the algorithm printout to see what
effect some of the options have.  For example, the option
<tt>NLPSolverClientInterface{opt_tol}</tt> is used in the Step
"CheckConvergence" under the name <tt>opt_tol</tt> in the files \ref
moocho_algo_sample_out_grp "MoochoAlgo.out" and \ref
moocho_journal_sample_out_grp "MoochoJournal.out".  Some of the options only
determine the algorithm configuration, which affects what steps are included,
how steps are set up and in what order they are included.  These option names
are not specifically shown in the algorithm printout per-say.  For example,
the option <tt>NLPAlgo_ConfigMamaJama{max_dof_quasi_newton_dense}</tt>
determines when the algorithm configuration will switch from using dense BFGS
to using limited-memory BFGS but this identifier name
<tt>max_dof_quasi_newton_dense</tt> is not shown anywhere in the listing.
However, the configuration object can print out a short log (to the
<tt>MoochoAlgo.out</tt> file) to show the user how these options impact the
configuration of the algorithm.

<b>Algorithm Summary and Timing Output (\ref moocho_summary_sample_out_grp "MoochoSummary.out")</b> \anchor moocho_summary_output_sec

The file \ref moocho_summary_sample_out_grp "MoochoSummary.out" contains a
more detailed summary table than what is sent to the console, a table of the
timings for each algorithm step for each iteration, and some limited
profiling-type output (produced by <tt>Teuchos::TimeMonitor</tt>).

<b>Algorithm Journal Output (\ref moocho_journal_sample_out_grp "MoochoJournal.out")</b> \anchor moocho_journal_output_sec

The file \ref moocho_journal_sample_out_grp "MoochoJournal.out" contains more
detailed, iteration by iteration, step by step information on what the
algorithm is doing.  The steps shown in this output are the same that are
shown in the pseudo algorithm description shown in the file \ref
moocho_algo_output_sec "MoochoAlgo.out" described above.  The amount of output
produced in this file is mainly controlled by the option
<tt>NLPSolverClientInterface{journal_output_level}</tt> and the value of
<tt>PRINT_ALGORITHM_STEPS</tt> is usually the most appropriated in most cases
and prints only \f$O(k)\f$ output, where \f$k\f$ is the SQP iteration counter.
The value of <tt>ITERATION_QUANTITIES</tt> will produce obscene amounts of
debugging output and will dump nearly every vector and every matrix used in
the algorithm.  There are many options in the \ref
Moocho_all_documentation_opts "Moocho.opt" options file that control exactly
what type of output is generated to meet different needs.  Note that the
option <tt>NLPSolverClientInterface{null_space_journal_output_level}</tt> will
override <tt>NLPSolverClientInterface{journal_output_level}</tt> for
quantities that lie in the null space.  This is helpful for seeing the
progress of the algorithm where there are few degrees of optimization freedom.

<!--
ToDo: Mention input of initial guess and output of solution for Thyra-based
problems.
-->

\subsubsection moocho_quickstart_algo_interrupt_sec Algorithm Interruption

All MOOCHO algorithms can be interrupted at any time while the algorithm is
running and result in a graceful termination, even for parallel runs with MPI.
When running in interactive mode (i.e. the user has access to standard in and
standard out at the console) then typing <tt>Ctrl-C</tt> will cause the
algorithm to pause at the end of the current algorithm step and menu like the
following will appear:

\verbatim

IterationPack::Algorithm::interrupt(): Received signal SIGINT.  Wait for
the end of the current step and respond to an interactive query,  kill
the process by sending another signal (i.e. SIGKILL).

IterationPack::Algorithm: Received signal SIGINT.
Just completed current step curr_step_name = "EvalNewPoint", curr_step_poss = 1
of steps [1...9].
Do you want to:
  (a) Abort the program immediately?
  (c) Continue with the algorithm?
  (s) Gracefully terminate the algorithm at the end of this step?
  (i) Gracefully terminate the algorithm at the end of this iteration?
Answer a, c, s or i ?

\endverbatim

To terminate the algorithm gracefully at the end of the current step, type
'<tt>s</tt>', which brings up the next question:

\verbatim
Terminate the algorithm with true (t) or false (f) ?
\endverbatim

Answering false ('<tt>f</tt>'), which is interpreted as failure, results in
the algorithm exiting immediately with the partial solution being returned to
the NLP object and everything being cleaned up correctly on exit.  The full
output from this type of interrupt looks something like:

\verbatim

********************************
*** Start of rSQP Iterations ***
n = 1331, m = 1111, nz = 1478741

 k    f         ||c||s    ||rGL||s  QN ||Ypy||2 ||Zpz||2 ||d||inf alpha    time(s)
 ---- --------- --------- --------- -- -------- -------- -------- -------- ---------
    0       2.1      0.11     0.095 IN   1e+001        7        5        1     1.152
    1       4.3   0.00025      0.27 UP      0.1        2      0.1        1     2.294
    2       4.1  8.5e-006      0.25 DU    0.007        3      0.3        1     3.405

IterationPack::Algorithm::interrupt(): Received signal SIGINT.  Wait for the end of
the current step and respond to an interactive query,  kill the process by sending
another signal (i.e. SIGKILL).

IterationPack::Algorithm: Received signal SIGINT.
Just completed current step curr_step_name = "EvalNewPoint",  curr_step_poss = 1 of
steps [1...9].
Do you want to:
  (a) Abort the program immediately?
  (c) Continue with the algorithm?
  (s) Gracefully terminate the algorithm at the end of this step?
  (i) Gracefully terminate the algorithm at the end of this iteration?
Answer a, c, s or i ? s

Terminate the algorithm with true (t) or false (f) ? f

 ---- --------- --------- --------- --
    3       3.4         -         -  -        -        -        -        -     7.762

Total time = 7.762 sec

Oops!  Not the solution.  The user terminated the algorithm and said to return non-optimal!

Number of function evaluations:
-------------------------------
f(x)  : 10
c(x)  : 10
Gf(x) : 5
Gc(x) : 5
Some algorithmic error occurred!

\endverbatim

A MOOCHO algorithm can also be interrupted without access to standard in or
standard out (i.e. when running in batch mode) by setting up an interrupt
file.  When the interrupt file is found, the algorithm is terminated.  MOOCHO
must be told to look for an interrupt file by setting the option
<tt>IterationPack_Algorithm{interrupt_file_name="interrupt.in"}</tt> where any
file name can be substituted for the name <tt>"interrupt.in"</tt>.  At the end
of each algorithm step, MOOCHO will look for the file <tt>"interrupt.in"</tt>,
usually in its current working directory (or an absolute path can be specified
as well).  If it finds the file it will read it for termination instructions.
For example, a interruption file that contains

\verbatim
i f
\endverbatim

will result in the algorithm terminating at the end of the current iteration
with the condition '<tt>false</tt>', which means failure.  The output
generated from this type of interrupt looks something like:

\verbatim

********************************
*** Start of rSQP Iterations ***
n = 1331, m = 1111, nz = 1478741

 k    f         ||c||s    ||rGL||s  QN ||Ypy||2 ||Zpz||2 ||d||inf alpha    time(s)
 ---- --------- --------- --------- -- -------- -------- -------- -------- ---------
    0       2.1      0.11     0.095 IN   1e+001        7        5        1     1.161
    1       4.3   0.00025      0.27 UP      0.1        2      0.1        1     2.293
    2       4.1  8.5e-006      0.25 DU    0.007        3      0.3        1     3.455

IterationPack::Algorithm: Found the interrupt file "interrupt.in"!
Just completed current step curr_step_name = "EvalNewPoint",  curr_step_poss = 1 of
steps [1...9].
Read a value of abort_mode = 'i': Will abort the program gracefully at the end of
this iteration!
Read a value of terminate_bool = 'f': Will return a failure flag!

    3       3.4  1.6e-005      0.23 DU    0.006        7        2        1     4.616
 ---- --------- --------- --------- --
    3       3.4  1.6e-005      0.23 DU    0.006        7        2        1     4.626

Total time = 4.626 sec

Oops!  Not the solution.  The user terminated the algorithm and said to return
non-optimal!

Number of function evaluations:
-------------------------------
f(x)  : 11
c(x)  : 11
Gf(x) : 5
Gc(x) : 5
Some algorithmic error occurred!

\endverbatim

Currently when an algorithm is interrupted and terminated, only the current
status of the solution variables are returned to the NLP (i.e. through the
<tt>Thyra::ModelEvaluator::reportFinalPoint()</tt> callback function) and no
internal check-pointing is performed.  Therefore, a user should not expect to
be able to restart an interrupted algorithm and have it behave the same as if
it was never interrupted.  MOOCHO currently does not support general
check-pointing and restarting but this is a feature that is on the wish list
for MOOCHO for an upcoming release.

This brings the MOOCHO quickstart to a conclusion.  The remaining sections
provide more detailed information on topics mentioned in the above quickstart.

\section moocho_nlps_sec Representing Nonlinear Programs for MOOCHO to Solve

In order to utilize the most powerful rSQP algorithms in MOOCHO the NLP
subclass must support the <tt><em>NLPInterfacePack::NLP</em></tt>,
<tt><em>NLPInterfacePack::NLPFirstOrder</em></tt>, and
<tt><em>NLPInterfacePack::NLPVarReductPerm</em></tt> interfaces and must
supply an object that supports the
<tt><em>AbstractLinAlgPack::BasisSystem</em></tt> and
<tt><em>AbstractLinAlgPack::BasisSystemPerm</em></tt> interfaces.  The details
of these interfaces are really not the concern of a general user who just
wants to solve an NLP.  Therefore, here we will only discuss some of the basic
issues associated with these interfaces and what adapter-support subclasses
are available to help implement the needed functionality.

As described above in the quickstart, there are two well supported tracts to
developing concrete NLP subclasses to be used with MOOCHO.  Each of these
tracts provides support software that allow the user to provide only the most
basic types of information needed to define the NLP.  The first type of NLPs
that are supported are general NLPs with explicit derivative components and
these NLPs can only be solved in serial.  This first type requires a direct
linear solver that can be used to select a basis matrix.  The second type are
simulation-constrained NLPs that can be solved on massively parallel computers
by utilizing preconditioned iterative linear solvers.  This type of NLP is
supported through the <tt>Thyra::ModelEvaluator</tt> interface and can utilize
much of the linear solver capability in Trilinos.  The key difference in this
second type of NLP is that the application must know <em>a priori</em> what
the selection of state (or dependent) variables is in order to obtain a square
and well conditioned basis matrix.

These two approaches to defining NLPs are described in the next two sections
\ref moocho_explicit_nlps_sec and \ref moocho_simulation_constrained_nlps_sec.

\subsection moocho_explicit_nlps_sec Representing General Serial NLPs with Explicit Jacobian Entries

One type of NLP that MOOCHO can solve are general NLPs where explicit gradient
and Jacobian entries are available.  This means that the gradient of the
objective function \f$\nabla f\f$ must be available in vector coefficient form
and the gradient of the constraints matrix \f$\nabla c\f$ (i.e. the
rectangular Jacobian \f$\frac{\partial c}{\partial x}=\nabla c^T\f$) must be
available in sparse matrix form.  In this type of problem, a basis matrix for
the constraints need not be known <i>a priori</i> but this requires the
availability of a linear direct solver that can be used to find a square
nonsingular basis from a rectangular matrix.  There are a few direct solvers
available that could in principle find a square basis given a rectangular
input matrix but MOOCHO only currently contains wrappers for LAPACK
(i.e. dense factorization using <tt>DEGETRF(...)</tt>) and the Harwell
Subroutine Library (HSL) routine MA28.  The MA28 routine is the only viable
option currently supported for handling large sparse linear systems.  In the
past, other direct solvers have been experimented with and an ambitious user
can provide support for any direct solver they would like (with the ability to
find a square basis) by providing an implementation of the
<tt>AbstractLinAlgPack::DirectSparseSolver</tt> interface.  If your NLP can
also provide explicit objective function gradients, then your concrete
subclass should derive from the
<tt>NLPInterfacePack::NLPSerialPreprocessExplJac</tt> subclass.  More details
are given below.

The first utility base subclass for general serial (i.e. runs in a single
process or perhaps on an SMP) NLPs is
<tt>NLPInterfacePack::NLPSerialPreprocess</tt>.  This utility class derives
from the <tt><em>NLPInterfacePack::NLP</em></tt>,
<tt><em>NLPInterfacePack::NLPObjGrad</em></tt>, and
<tt><em>NLPInterfacePack::NLPVarReductPerm</em></tt> interfaces and takes care
of a lot of details like preprocessing out fixed variables, converting general
inequality constraints to equalities by the addition of slack variables and
maintaining the current basis permutations.  All of this is done to transform
the "original" NLP into standard form.  The "original" NLP can include general
inequality constraints in addition to general equality constraints.  The
"original" NLP, however, can also includes fixed variables (i.e. \f$(x_L)_{(i)}
= (x_U)_{(i)}\f$).  There are several different intermediate forms of the NLP
that a <tt>NLPSerialPreprocess</tt> object maintains in the transformation
from the ``original'' NLP to the final form.  The first type of transformation
is the addition of slack variables to convert the general inequality
constraints into an extra set of equality constraints.  This is called the
"full" form of the NLP.  The second type transformation is the removal of
fixed variables which are preprocessed out of the problem but leaving the
general inequalities intact which some parts of a MOOCHO algorithm may access
(e.g. globalization steps) through the <tt><em>NLP</em></tt> interface.  The
last type of transformation is the permutation of the variables and the
constraints according to the current basis selection.  All of this
functionality is very useful and this makes the <tt>NLPSerialPreprocess</tt>
subclass the place to start when going to implement any type of serial NLP to
be used with an rSQP algorithm.  Note that this subclass does not address the
structure or handling of the Jacobian or Hessian matrices in any way.  The
handling of these matrices is deferred to subclasses to define.

While it may seem that the details of the transformations performed by
<tt>NLPInterfacePack::NLPSerialPreprocess</tt> are of no concern to end users,
this is not always the case.  For example, a user must understand how their
original NLP is transformed in order to understand the output printed in the
\ref moocho_journal_output_sec "MoochoJournal.out" file when the journal
output level <tt>NLPSolverClientInterface{journal_print_level}</tt> is set to
a value equal to or higher than <tt>PRINT_VECTORS</tt>.

Subclasses that wish to use a generic sparse data structure for the Jacobian
matrix \f$\nabla c^T\f$ and a generic sparse direct linear solver to select,
factor and solve linear systems with the basis matrix \f$C\f$ should derive
from the <tt>NLPInterfacePack::NLPSerialPreprocessExplJac</tt> subclass (which
itself derives from <tt>NLPSerialPreprocess</tt>).  This subclass performs all
of the same types of transformations as its <tt>NLPSerialPreprocess</tt> base
class (i.e. removal of entries for fixed variables, addition of slack
variables and basis permutations) with the explicit Jacobian entries that are
supplied by the concrete NLP subclass.  The concrete implementations of both
the Jacobian matrix subclass for <tt>Gc</tt> and the
<tt><em>BasisSystem</em></tt> subclass can be overridden by the client but yet
have good default implementations.  The default implementation for the matrix
class for <tt>Gc</tt> is <tt>AbstractLinAlgPack::MatrixSparseCOORSerial</tt>
(which uses a coordinate sparse matrix format).  The implementation of the
<tt><em>AbstractLinAlgPack::BasisSystem</em></tt> object is handled through a
subclass of <tt><em>AbstractLinAlgPack::BasisSystemFactory</em></tt> called
<tt>AbstractLinAlgPack::BasisSystemFactoryStd</tt>.

The <tt>AbstractLinAlgPack::BasisSystemFactoryStd</tt> subclass can create
<tt><em>AbstractLinAlgPack::BasisSystem</em></tt> objects implemented through
several different direct linear solvers.  Currently, only the solvers
<tt>LAPACK</tt> (for small, dense Jacobians)and MA28 (for large, sparse
systems) are currently supported (see the options group
<tt>BasisSystemFactoryStd</tt> to select what solver to use manually).  Note
that MOOCHO must be configured with <tt>MOOCHO_ENABLE_MA28</tt> to support the
MA28 solver.

<b>Warning!</b> This NLP adapter-support software is going to most likely
change in a major way before the next major release of Trilinos.  Therefore,
it is recommended that, if possible, users derive their NLPs from the
%Thyra-based simulation-constrained interfaces described in the next section
\ref moocho_simulation_constrained_nlps_sec.  However, this set of software is
the only currently supported way to solve certain types of general NLPs and
therefore remains for the time being.

See examples above in the section \ref moocho_explicit_nlps_examples_sec.

\subsection moocho_simulation_constrained_nlps_sec Representing Simulation-Constrained Parallel NLPs through Thyra

Another type of NLP that can be solved using MOOCHO are simulation-constrained
NLPs where the basis section is known up front.  For these types of NLPs, it
is recommended that the NLP be specified through the
<tt>Thyra::ModelEvaluator</tt> interface and this provides access to a
significant linear solver capability through Trilinos.  These types of NLPs
can also be solved in single program multiple data (SPMD) mode in parallel on
a massively parallel computer.

The <tt>Thyra::ModelEvaluator</tt> interface uses a different notation than
the standard MOOCHO NLP notation.  The model evaluator notation is:

\f[
\begin{array}{rcl}
\mbox{minimize}   &  & g(x,p) \\
\mbox{subject to} &  & f(x,p) = 0 \\
                  &  & x_L \leq x    \leq x_U \\
                  &  & p_L \leq p    \leq p_U
\end{array}
\f]

where \f$x\in\Re^{n_x}\f$ are the state variables, \f$p\in\Re^{n_p}\f$ are the
optimization parameters, \f$f(x,p)=0\f$ are the discrete nonlinear state
simulation equations, and \f$g(x,p)\f$ is the scalar-valued objective
function.  Here the state Jacobian \f$\frac{\partial f}{\partial x}\f$ must be
square and nonsingular.  The partitioning of variables into state variables
\f$x\f$ and optimization variables \f$p\f$ must be known <em>a priori</em> and
this partitioning can not change during an optimization solve.

Comparing the MOOCHO notation for optimization problems using variable
decomposition methods which is

\f[
\begin{array}{rcl}
\mbox{minimize}   &  & f(x_D,x_I) \\
\mbox{subject to} &  & c(x_D,x_I) = 0 \\
                  &  & x_{D,L} \leq x_D \leq x_{D,U} \\
                  &  & x_{I,L} \leq x_I \leq x_{I,U}
\end{array}
\f]

we can see the mapping between the MOOCHO notation and the
<tt>Thyra::ModelEvaluator</tt> notation as summarized in the following table:

<table>

<caption> Mapping of notation between MOOCHO and
<tt>Thyra::ModelEvaluator</tt> for simulation-constrained optimization
problems.  </caption>

<tr> <td><b>MOOCHO Notation</b></td> <td><b><tt>Thyra::ModelEvaluator</tt> Notation</b></td>
<td><b><tt>Thyra::ModelEvaluator</tt> Description</b></td> </tr>

<tr> <td>\f$m\f$</td> <td>\f$n_x\f$</td> <td>Number of state variables</td> </tr>

<tr> <td>\f$n-m\f$</td> <td>\f$n_p\f$</td> <td>Number of optimization
parameters</td> </tr>

<tr> <td>\f$n\f$</td> <td>\f$n_x+n_p\f$</td> <td>Total number of optimization
variables</td> </tr>

<tr> <td>\f$x_D\in\Re^{m}\f$</td> <td>\f$x\in\Re^{n_x}\f$</td> <td>State
variables</td> </tr>

<tr> <td>\f$x_I\in\Re^{n-m}\f$</td> <td>\f$p\in\Re^{n_p}\f$</td>
<td>Optimization parameters</td> </tr>

<tr> <td>\f$c(x_D,x_I)\in\Re^{n}\rightarrow\Re^{m}\f$</td>
<td>\f$f(x,p)\Re^{n_x+n_p}\rightarrow\Re^{n_x}\f$</td> <td>State equation
residual function</td> </tr>

<tr> <td>\f$f(x_D,x_I)\in\Re^{n}\rightarrow\Re\f$</td>
<td>\f$g(x,p)\Re^{n_x+n_p}\rightarrow\Re\f$</td> <td>Objective function</td>
</tr>

<tr> <td>\f$C\in\Re^{m \times m}\f$</td> <td>\f$\frac{\partial f}{\partial
x}\in\Re^{n_x \times n_x}\f$</td> <td>Nonsingular state Jacobian</td> </tr>

<tr> <td>\f$N\in\Re^{m \times n-m}\f$</td> <td>\f$\frac{\partial f}{\partial
p}\in\Re^{n_x \times n_p}\f$</td> <td>Optimization Jacobian</td> </tr>

<tr> <td>\f$\nabla_D f^T\in\Re^{1 \times m}\f$</td> <td>\f$\frac{\partial g}{\partial
x}\in\Re^{1 \times n_x}\f$</td> <td>Derivative of objective with respect to state variables</td> </tr>

<tr> <td>\f$\nabla_I f^T\in\Re^{1 \times n-m}\f$</td> <td>\f$\frac{\partial
g}{\partial p}\in\Re^{1 \times n_p}\f$</td> <td>Derivative of objective with
respect to optimization parameters</td> </tr>

</table>

It is unfortunate that the notation used with the Model Evaluator interfaces
and software are different than those used by MOOCHO.  The reason for this
change in notation is that the Model Evaluator had to first appeal to the
forward solve community where \f$f(x,p)=0\f$ is the standard notation for the
parameterized state equation and changing the notation of all of MOOCHO after
the fact to match this would be very tedious to perform.  We can only hope
that the user can keep the above mapping of notation straight between MOOCHO
and the Model Evaluator.

Currently, and more so in the near future, a great deal of capability will be
automatically available when a user provides an implementation of the
<tt>EpetraExt::ModelEvaluator</tt> interface (as shown in the section \ref
moocho_simulation_constrained_nlps_examples_sec).  For these types of NLPs, a
great deal of linear solver capability is available through the linear solver
and preconditioners wrappers in the <a
href="../../../stratimikos/doc/html/index.html">Stratimikos</a> package.  In
addition, the application will also have access to many other nonlinear
algorithms provided in Trilinos (see the Trilinos packages NOX, LOCA, and
Rythmos).

See examples above in the section \ref
moocho_simulation_constrained_nlps_examples_sec.

\section moocho_dependencies_sec Other Trilinos Packages on which MOOCHO Directly Depends

%MOOCHO has direct dependencies on the following Trilinos packages:

<ul>

<li><b><a href="../../../teuchos/doc/html/index.html">teuchos</a></b>: This
package supplies basic utility classes such as <tt>Teuchos::RCP</tt>
and <tt>Teuchos::BLAS</tt> that %MOOCHO software is dependent on.

<li><b><a href="../../../rtop/doc/html/index.html">rtop</a></b>: This package
supplies the basic interfaces for vector reduction/transformation operators as
well as support code and a library of pre-written RTOp subclasses.  Much of
the software in MOOCHO depends on this code.

</ul>

%MOOCHO also optionally directly depends on the following Trilinos packages:

<ul>

<li><b><a href="../../../thyra/doc/html/index.html">thyra</a></b>: This
package supplies interfaces and support software for SPMD and other types of
computing platforms and defines the interface <tt>Thyra::ModelEvaluator</tt>
for simulation-constrained optimization that MOOCHO can use to define NLPs.

<li><b><a href="../../../epetraext/doc/html/index.html">epetraext</a></b>:
This package provides an Epetra-specific interface for the model evaluator
called <tt>EpetraExt::ModelEvaluator</tt> and contains some concrete examples
that are used by MOOCHO.

<li><b><a href="../../../stratimikos/doc/html/index.html">stratimikos</a></b>:
This package supplies %Thyra-based wrappers for several serial direct and
massively parallel iterative linear solvers and preconditioners.

</ul>

\section moocho_internal_links_sec Individual MOOCHO Doxygen Collections

Below are links to individual doxygen collections that make up MOOCHO:

<ul>

<li><b><a
href="../../src/MoochoUtilities/doc/html/index.html">MoochoUtilities</a></b>:
Collection of a small amount of utility code that is peculiar to MOOCHO.  Some
of the software that is now in <tt>%Teuchos</tt> such as
<tt>Teuchos::RCP</tt> and <tt>Teuchos::CommandLineProcessor</tt> were
once in this collection.

<li><b><a
href="../../src/IterationPack/doc/html/index.html">IterationPack</a></b>:
"Framework" for building iterative algorithms that MOOCHO is based on.

<li><b><a href="../../src/RTOpPack/doc/html/index.html">RTOpPack</a></b>:
Legacy RTOp code that predates %Thyra the Trilinos %RTOp package but it still
used by MOOCHO.  The current version of the Trilinos <tt><a
href="../../../rtop/doc/html/index.html">RTOp</a></tt> package was developed from
refactored code that once lived in this collection.

<li><b><a
href="../../src/DenseLinAlgPack/doc/html/index.html">DenseLinAlgPack</a></b>:
A C++ class library for dense, BLAS-compatible, serial linear algebra that is
similar to classes like <tt>Teuchos::SerialDenseVector</tt> and
<tt>Teuchos::SerialDenseMatrix</tt>.  This class library is used exclusively
by MOOCHO to deal with serial dense linear algebra.

<li><b><a
href="../../src/AbstractLinAlgPack/doc/html/index.html">AbstractLinAlgPack</a></b>:
A C++ class library for abstract linear algebra.  These interfaces predate and
helped to inspire %Thyra but at this point should be considered legacy
software that should only be used within MOOCHO.  It is likely that a future
refactoring of MOOCHO will involve largely removing these classes and using
Thyra-based software directly instead.

<li><b><a
href="../../src/NLPInterfacePack/doc/html/index.html">NLPInterfacePack</a></b>:
Set of abstract interfaces based on <tt>%AbstractLinAlgPack</tt> for
representing nonlinear programs (NLPs) (i.e. optimization problems).  These
interfaces serve a similar role as the <tt>Thyra::ModelEvaluator</tt>
interface but there are many differences.  In the future, it is likely that
these interfaces will be refactored to look more like the
<tt>Thyra::ModelEvaluator</tt> interface but are likely to remain distinct.

<li><b><a
href="../../src/ConstrainedOptPack/doc/html/index.html">ConstrainedOptPack</a></b>:
Collection of utility software for building constrained optimization
algorithms that is based on <tt>%AbstractLinAlgPack</tt>.  Included here are
interfaces and adapters for QP solvers (with <tt>QPSchur</tt> being included
by default), line search interfaces and implementations, range/null space
decompositions and other such capabilities.

<li><b><a href="../../src/MoochoPack/doc/html/index.html">MoochoPack</a></b>:
Provides nonlinear optimization algorithms for primarily rSQP methods based on
the <tt>%IterationPack</tt> framework.  This is where the real algorithmic
meat of nonlinear programing is found in MOOCHO.  This collection provides the
"Facade" class <tt>MoochoPack::MoochoSolver</tt>.

<li><b><a href="../../thyra/doc/html/index.html">MOOCHO/Thyra
Adapters</a></b>: Provides adapter classes for allowing MOOCHO to solve
simulation-constrained optimization problems presented as
<tt>Thyra::ModelEvaluator</tt> objects.  Also included is the higher-level "Facade" class
<tt>MoochoPack::MoochoThyraSolver</tt>.

</ul>

\section moocho_browse_sec Browse all of MOOCHO as a Single Doxygen Collection

You can browse all of MOOCHO as a <A HREF="../../browser/doc/html/index.html">single
doxygen collection</A>. Warning, this is not the recommended way to learn
about MOOCHO software.  However, this is a good way to browse the <a
href="../../browser/doc/html/dirs.html">directory structure of MOOCHO</a>, to
<a href="../../browser/doc/html/files.html">locate files</a>, etc.

\section moocho_links_sec Links to Other Documentation Collections

<ul>

<li><b><a href="../../../thyra/doc/html/index.html">Thyra</a></b>: This
package defines basic interfaces and support software for abstract numerical
algorithms.

<li><b><a href="../../../epetra/thyra/doc/html/index.html">Thyra ANA
Operator/Vector Adapters for Epetra</a></b>: This software includes the basic
adapters needed to wrap %Epetra objects and %Thyra objects.

<li><b><a href="../../../epetraext/thyra/doc/html/index.html">Various Thyra
Adapters for EpetraExt</a></b>: Included here are adapters and interfaces that
allow a perspective nonlinear application to specify everything needed to
define a wide range of nonlinear problems in terms by subclassing an
Epetra-based version of the <tt>Thyra::ModelEvaluator</tt> interface (called
<tt>EpetraExt::ModelEvaluator</tt>).  This software allows an appropriately
defined %Epetra-based model to be used to define a %Thyra-based model to be
used to define an optimization problem that MOOCHO can then solve.

<li><b><a href="../../../stratimikos/doc/html/index.html">Stratimikos: Unified
Wrappers for Thyra Linear Solver and Preconditioner Capabilities</a></b>:
Stratimikos contains neatly packaged access to all of the Thyra linear solver
and preconditioner wrappers.  Currently, these allow the creation of linear
solvers for nearly any <tt>Epetra_RowMatrix</tt> object.

</ul>

*/

/** \example NLPWBCounterExampleMain.cpp */

/** \example ExampleNLPBandedMain.cpp */

/** \example NLPThyraEpetraModelEval4DOptMain.cpp

\anchor moocho_NLPThyraEpetraModelEval4DOptMain_tag

 */

/** \example NLPThyraEpetraAdvDiffReactOptMain.cpp */

/** \defgroup moocho_sample_inout_output_files_grp Sample MOOCHO input and output. */

/** \defgroup moocho_option_sample_grp Sample MOOCHO Options File

\ingroup moocho_sample_inout_output_files_grp

Below is a sample MOOCHO options file for some of the typical options that a
user might want to manipulate.  The full set of options with documentation are
shown \ref Moocho_all_documentation_opts "here".

\verbinclude Moocho.sample.opt

*/

/** \defgroup moocho_console_sample_out_grp Sample MOOCHO Console Output

\ingroup moocho_sample_inout_output_files_grp

Below is the console output generated by the program
<tt>ExampleNLPBanded.exe</tt> using the command-line arguments

\verbinclude ExampleNLPBanded.cmndline.input.txt

given the <tt>Moocho.opt</tt> options file shown
\ref moocho_option_sample_grp "here".

Here is the other types of output that is associated with this run:

<ul>
<li>\ref moocho_algo_sample_out_grp
<li>\ref moocho_summary_sample_out_grp
<li>\ref moocho_journal_sample_out_grp
</ul>

<b>Console output:</b>

\verbinclude ExampleNLPBanded.sample.out

*/

/** \defgroup moocho_algo_sample_out_grp Sample MOOCHO Algorithm Configuration Output (MoochoAlgo.out)

\ingroup moocho_sample_inout_output_files_grp

Below is the output file <tt>MoochoAlgo.out</tt> from the program
<tt>ExampleNLPBanded.exe</tt> using the command-line arguments

\verbinclude ExampleNLPBanded.cmndline.input.txt

given the <tt>Moocho.opt</tt> options file shown
\ref moocho_option_sample_grp "here".

Here is the other types of output that is associated with this run:

<ul>
<li>\ref moocho_console_sample_out_grp
<li>\ref moocho_summary_sample_out_grp
<li>\ref moocho_journal_sample_out_grp
</ul>

<b>Output file <tt>MoochoAlgo.out</tt>:</b>

\verbinclude MoochoAlgo.ExampleNLPBanded.sample.out

*/

/** \defgroup moocho_summary_sample_out_grp Sample MOOCHO Algorithm Summary Output (MoochoSummary.out)

\ingroup moocho_sample_inout_output_files_grp

Below is the output file <tt>MoochoSummary.out</tt> from the program
<tt>ExampleNLPBanded.exe</tt> using the command-line arguments

\verbinclude ExampleNLPBanded.cmndline.input.txt

given the <tt>Moocho.opt</tt> options file shown
\ref moocho_option_sample_grp "here".

Here is the other types of output that is associated with this run:

<ul>
<li>\ref moocho_console_sample_out_grp
<li>\ref moocho_algo_sample_out_grp
<li>\ref moocho_journal_sample_out_grp
</ul>

<b>Output file <tt>MoochoSummary.out</tt>:</b>

\verbinclude MoochoSummary.ExampleNLPBanded.sample.out

*/

/** \defgroup moocho_journal_sample_out_grp Sample MOOCHO Algorithm Journal Output (MoochoJournal.out)

\ingroup moocho_sample_inout_output_files_grp

Below is the output file <tt>MoochoJournal.out</tt> from the program
<tt>ExampleNLPBanded.exe</tt> using the command-line arguments

\verbinclude ExampleNLPBanded.cmndline.input.txt

given the <tt>Moocho.opt</tt> options file shown
\ref moocho_option_sample_grp "here".

Here is the other types of output that is associated with this run:

<ul>
<li>\ref moocho_console_sample_out_grp
<li>\ref moocho_algo_sample_out_grp
<li>\ref moocho_summary_sample_out_grp
</ul>

<b>Output file <tt>MoochoJournal.out</tt>:</b>

\verbinclude MoochoJournal.ExampleNLPBanded.sample.out

*/
