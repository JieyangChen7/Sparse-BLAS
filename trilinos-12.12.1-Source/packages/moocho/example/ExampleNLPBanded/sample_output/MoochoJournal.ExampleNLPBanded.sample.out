
********************************************************************
*** Algorithm iteration detailed journal output                  ***
***                                                              ***
*** Below, detailed information about the SQP algorithm is given ***
*** while it is running.  The amount of information that is      ***
*** produced can be specified using the option                   ***
*** NLPSolverClientInterface::journal_output_level (the default ***
*** is PRINT_NOTHING and produces no output                      ***
********************************************************************

*** Echoing input options ...

begin_options

options_group DecompositionSystemStateStepBuilderStd {
    null_space_matrix = EXPLICIT;
    range_space_matrix = ORTHOGONAL;
}

options_group NLPAlgoConfigMamaJama {
    line_search_method = FILTER;
    quasi_newton = BFGS;
}

options_group NLPSolverClientInterface {
    calc_conditioning = true;
    calc_matrix_info_null_space_only = true;
    calc_matrix_norms = true;
    feas_tol = 1e-7;
    journal_output_level = PRINT_ALGORITHM_STEPS;
    journal_print_digits = 10;
    max_iter = 20;
    max_run_time = 2.0;
    null_space_journal_output_level = PRINT_ITERATION_QUANTITIES;
    opt_tol = 1e-2;
}

end_options


*** Setting up to run MOOCHO on the NLP using a configuration object of type 'MoochoPack::NLPAlgoConfigMamaJama' ...

*****************************
*** MoochoSolver::solve() ***
*****************************

test_nlp = true: Testing the NLP! ...

Testing the supported NLPFirstOrder interface ...

*********************************
*** test_nlp_first_order(...) ***
*********************************

Testing the vector spaces ...

Testing nlp->space_x() ...
nlp->space_x() checks out!

Testing nlp->space_c() ...
nlp->space_c() checks out!

**************************************
*** NLPTester::test_interface(...) ***
**************************************

nlp->force_xinit_in_bounds(true)
nlp->initialize(true)

*** Dimensions of the NLP ...

nlp->n()  = 3005
nlp->m()  = 3000

*** Validate the dimensions of the vector spaces ...

check: nlp->space_x()->dim() = 3005 == nlp->n() = 3005: true

check: nlp->space_c()->dim() = 3000 == nlp->m() = 3000: true

*** Validate that the initial starting point is in bounds ...

||nlp->xinit()||inf = 1.00000000e-01

check: xl <= x <= xu : true
xinit is in bounds with { max |u| | xl <= x + u <= xu } -> 1.00000000e+50

check: num_bounded(nlp->xl(),nlp->xu()) = 5 == nlp->num_bounded_x() = 5: true

Getting the initial estimates for the Lagrange mutipliers ...

||lambda||inf  = 0.00000000e+00
||nu||inf      = 0.00000000e+00
nu.nz()        = 0

*** Evaluate the point xo ...

||xo||inf = 1.00000000e-01

f(xo) = 1.50250000e+01
||c(xo)||inf = 1.19973085e+02

*** Report this point to the NLP as suboptimal ...

*** Print the number of evaluations ...

nlp->num_f_evals() = 1
nlp->num_c_evals() = 1

Calling nlp->calc_Gc(...) at nlp->xinit() ...

Calling nlp->calc_Gf(...) at nlp->xinit() ...

Comparing directional products Gf'*y and/or Gc'*y with finite difference values  FDGf'*y and/or FDGc'*y for random y's ...

****
**** Random directional vector 1 ( ||y||_1 / n = 5.02523278e-01 )
***

rel_err(Gf'*y,FDGf'*y) = rel_err(-3.72976994e+00,-3.72976994e+00) = 1.20314339e-13

rel_err(sum(Gc'*y),sum(FDGc'*y)) = rel_err(3.34447607e+03,3.34447607e+03) = 3.22588066e-13

Congradulations!  All of the computed errors were within the specified error tolerance!

Successful end of testing of the nlp

************************************
*** MoochoSolver::solve_nlp()    ***
************************************

*** Starting iterations ...


(0) 1: "EvalNewPoint"

x is not updated for any k so set x_k = nlp.xinit() ...

||x_k||inf            = 1.0000000000e-01

Updating the decomposition ...

DecompositionSystemVarReductPerm object currently does not have a basis so we must select one ...

The NLP will attempt to select a basis (k = 0)...

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Must allocate a new matrix object for D = -inv(C)*N since one has not been allocated yet ...

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

Must allocate a new basis matrix object for C since one has not been allocated yet ...

Allocated a new basis matrix object C of type 'AbstractLinAlgPack::MatrixOpNonsingAggr' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Using a direct sparse solver to set a new basis ...

Using LAPACK xGETRF to analyze and factor a new matrix ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 1.5025000000e+01
||Gf_k||inf              = 1.0000000000e-01
||Gf_k(var_dep)_k||inf   = 1.0000000000e-01
||Gf_k(var_indep)_k||inf = 1.0000000000e-01
||c_k||inf               = 1.1997308452e+02

Gf(var_indep)_k =
 5
  0.1:1 0.1:2 0.1:3 0.1:4 0.1:5

(0) 2: "QuasiNormalStep"

||py||   = 4.7998936932e-03

||Ypy||2 = 1.1999603325e+00

(0) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 4.0008087749e-05

num_basis_k was updated so the basis changed so we will skip this check
    reset min ||py||/||c|| to current value + 1

(0) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 1.3784529074e-11 / (1.1997308452e+02 + 2.2250738585e-308)
     = 1.1489684648e-13

num_basis_k was updated so the basis changed so we will skip this check
    reset min ||R*py+c||/||c|| to current value + epsilon(2.2204460493e-16)

(0) 3: "ReducedGradient"

||rGf||inf = 1.0809594644e+01

rGf_k =
 5
  -10.8086:1 -10.8091:2 -10.8091:3 -10.8091:4 -10.8096:5

(0) 4.-1: "CheckSkipBFGSUpdate"

(0) 4: "ReducedHessian"

Initializing rHL = eye(n-r) (k = 0)...

||rHL_k||inf    = 1.0000000000e+00

cond_inf(rHL_k) = 1.0000000000e+00

rHL_k = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   1:1:1 0:1:2 1:1:3 0:1:4 0:1:5
   0:2:1 1:2:2 0:2:3 1:2:4 0:2:5
   0:3:1 0:3:2 1:3:3 0:3:4 1:3:5
   0:4:1 0:4:2 0:4:3 1:4:4 0:4:5
   0:5:1 0:5:2 0:5:3 0:5:4 1:5:5
 Matrix scaling M = scale*U'*U, scale = 1
 Upper cholesky factor U (ignore lower nonzeros):
  5 5
   1:1:1 0:1:2 0:1:3 0:1:4 0:1:5
   0:2:1 1:2:2 0:2:3 0:2:4 0:2:5
   1:3:1 0:3:2 1:3:3 0:3:4 0:3:5
   0:4:1 1:4:2 0:4:3 1:4:4 0:4:5
   0:5:1 0:5:2 1:5:3 0:5:4 1:5:5

(0) 5.-1: "SetDBoundsStd"

(0) 5: "TangentialStep"

qp_grad_k = 
 5
  -10.8086:1 -10.8091:2 -10.8091:3 -10.8091:4 -10.8096:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 5.2360290589e-01

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 1.0809594644e+01
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+00
||Zpz_k||2     = 1.1032346914e+02

pz_k = 
 5
  10.8086:1 10.8091:2 10.8091:3 10.8091:4 10.8096:5

nu_k(var_indep) = 
 5
  0:1 0:2 0:3 0:4 0:5

Zpz(var_indep)_k = 
 5
  10.8086:1 10.8091:2 10.8091:3 10.8091:4 10.8096:5


(0) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-1.3207213101e-12)/(1.1999603325e+00 * 1.1032346914e+02 + 2.2250738585e-308)
  = -9.9764581665e-15

||d_k||inf            = 1.0285991738e+01

(0) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 1.0809594644e+01

rGL_k = 
 5
  -10.8086:1 -10.8091:2 -10.8091:3 -10.8091:4 -10.8096:5

(0) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.1000000000e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 9.8269042215e+00 > opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 1.1997308452e+02 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = -0.0000000000e+00 < comp_tol = 1.0000000000e-06
step_err         = 9.3509015798e+00 > step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 0) :-(

(0) 9.-1: "LineSearchFullStep"

f_k        = 1.5025000000e+01
||c_k||inf = 1.1997308452e+02
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 1.0385991738e+01

f_kp1        = 5.5154949366e+03
||c_kp1||inf = 2.4039402261e+05

(0) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.1792252057e+02

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
Filter is empty.

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 5.5154949366e+03 2.3625283841e+05          failed      Fraction Reduction (! Switch Cond )|
|5.0000000000e-01 1.2436714997e+03 3.3614573874e+04          failed      Fraction Reduction (! Switch Cond )|
|2.5000000000e-01 2.4895113274e+02 5.1562325845e+03          failed      Fraction Reduction (! Switch Cond )|
|1.2500000000e-01 3.6888787086e+01 8.1127274965e+02          failed      Fraction Reduction (! Switch Cond )|
|6.2500000000e-02 2.1820737219e+00 6.8472167804e+01        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 2.1820737219e+00 - 1.0000000000e-05*6.8472167804e+01 = 2.1813890002e+00
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*6.8472167804e+01 = 6.8471483083e+01

(1) 1: "EvalNewPoint"

||x_k||inf            = 7.4287448361e-01
||x(var_dep)_k||inf   = 2.3136269747e-02
||x(var_indep)_k||inf = 7.4287448361e-01

x(var_indep)_k = 
 5
  0.742812:1 0.742843:2 0.742843:3 0.742843:4 0.742874:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 2.1820737219e+00
||Gf_k||inf              = 7.4287448361e-01
||Gf_k(var_dep)_k||inf   = 2.3136269747e-02
||Gf_k(var_indep)_k||inf = 7.4287448361e-01
||c_k||inf               = 6.9682547090e+01

Gf(var_indep)_k =
 5
  0.742812:1 0.742843:2 0.742843:3 0.742843:4 0.742874:5

(1) 2: "QuasiNormalStep"

||py||   = 1.6259405998e-02

||Ypy||2 = 1.0621477516e+00

(1) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 2.3333541435e-04

(1) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 6.8212102633e-13 / (6.9682547090e+01 + 2.2250738585e-308)
     = 9.7889795195e-15

(1) 3: "ReducedGradient"

||rGf||inf = 3.7462461296e-01

rGf_k =
 5
  0.374625:1 0.374464:2 0.374464:3 0.374464:4 0.374303:5

(1) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(2.4169862058e+01+6.4588832268e+03))
        * (1.1032346914e+02/1.1999603325e+00)
      = 1.1418557184e+01
ratio > 1
Perform BFGS update if you can ...

(1) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 1.1183897541e+01

||s_bfgs||inf = 6.7559966523e-01

y_bfgs =
 5
  11.1832:1 11.1836:2 11.1836:3 11.1836:4 11.1839:5

s_bfgs =
 5
  0.675537:1 0.675568:2 0.675568:3 0.675568:4 0.6756:5

Rescaling the initial identity matrix before the update as:
Iscale = (y'*y)/(y'*s) = (6.2535947673e+02)/(3.7776268532e+01) = 1.6554294562e+01
B =  Iscale * eye(n-r) ...

B after rescaling = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   16.5543:1:1 0:1:2 1:1:3 0:1:4 0:1:5
   0:2:1 16.5543:2:2 0:2:3 1:2:4 0:2:5
   0:3:1 0:3:2 16.5543:3:3 0:3:4 1:3:5
   0:4:1 0:4:2 0:4:3 16.5543:4:4 0:4:5
   0:5:1 0:5:2 0:5:3 0:5:4 16.5543:5:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 3.7776268532e+01 >=  s_bfgs' * B * s_bfgs = 3.7776268535e+01
Perform the undamped update ...

B after the BFGS update = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   16.5544:1:1 0:1:2 1:1:3 0:1:4 0:1:5
   5.27915e-05:2:1 16.5543:2:2 0:2:3 1:2:4 0:2:5
   5.27878e-05:3:1 1.1783e-08:3:2 16.5543:3:3 0:3:4 1:3:5
   5.27841e-05:4:1 8.12156e-09:4:2 4.46017e-09:4:3 16.5543:4:4 0:4:5
   -4.02538e-09:5:1 -5.27841e-05:5:2 -5.27878e-05:5:3 -5.27914e-05:5:4 16.5542:5:5

||rHL_k||inf    = 1.6554558493e+01

cond_inf(rHL_k) = 1.0000318885e+00

rHL_k = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   16.5544:1:1 0:1:2 4.0687:1:3 2.85463e-09:1:4 1.95474e-09:1:5
   5.27915e-05:2:1 16.5543:2:2 0:2:3 4.0687:2:4 1.05485e-09:2:5
   5.27878e-05:3:1 1.1783e-08:3:2 16.5543:3:3 0:3:4 4.0687:3:5
   5.27841e-05:4:1 8.12156e-09:4:2 4.46017e-09:4:3 16.5543:4:4 0:4:5
   -4.02538e-09:5:1 -5.27841e-05:5:2 -5.27878e-05:5:3 -5.27914e-05:5:4 16.5542:5:5
 Matrix scaling M = scale*U'*U, scale = 1
 Upper cholesky factor U (ignore lower nonzeros):
  5 5
   4.06871:1:1 1.2975e-05:1:2 1.29741e-05:1:3 1.29732e-05:1:4 -9.8935e-10:1:5
   0:2:1 4.0687:2:2 2.85463e-09:2:3 1.95474e-09:2:4 -1.29732e-05:2:5
   16.5543:3:1 0:3:2 4.0687:3:3 1.05485e-09:3:4 -1.29741e-05:3:5
   1.1783e-08:4:1 16.5543:4:2 0:4:3 4.0687:4:4 -1.2975e-05:4:5
   8.12156e-09:5:1 4.46017e-09:5:2 16.5543:5:3 0:5:4 4.06868:5:5

(1) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -0.742802:1 -0.742833:2 -0.742833:3 -0.742833:4 -0.742864:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(1) 5: "TangentialStep"

qp_grad_k = 
 5
  0.374625:1 0.374464:2 0.374464:3 0.374464:4 0.374303:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 2.5901993894e-01

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 2.2629695306e-02
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+00
||Zpz_k||2     = 6.0331754008e-02

pz_k = 
 5
  -0.0226297:1 -0.0226203:2 -0.0226203:3 -0.0226203:4 -0.022611:5

nu_k(var_indep) = 
 5
  0:1 0:2 0:3 0:4 0:5

Zpz(var_indep)_k = 
 5
  -0.0226297:1 -0.0226203:2 -0.0226203:3 -0.0226203:4 -0.022611:5


(1) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-1.9637069748e-15)/(1.0621477516e+00 * 6.0331754008e-02 + 2.2250738585e-308)
  = -3.0644024221e-14

||d_k||inf            = 2.8163092161e-01
||d(var_dep)_k||inf   = 1.5659094503e-02
||d(var_indep)_k||inf = 2.8163092161e-01

d(var_indep)_k = 
 5
  -0.281457:1 -0.281544:2 -0.281544:3 -0.281544:4 -0.281631:5

(1) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 3.7462461296e-01

rGL_k = 
 5
  0.374625:1 0.374464:2 0.374464:3 0.374464:4 0.374303:5

(1) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.7428744836e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.1494640979e-01 > opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 6.9682547090e+01 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = -0.0000000000e+00 < comp_tol = 1.0000000000e-06
step_err         = 1.6158990464e-01 > step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 1) :-(

(1) 9.-1: "LineSearchFullStep"

f_k        = 2.1820737219e+00
||c_k||inf = 6.9682547090e+01
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 4.6135478069e-01

f_kp1        = 6.1576438692e-01
||c_kp1||inf = 1.5830011682e+01

(1) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 6.8472167804e+01

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|         2.1813890002e+00          6.8471483083e+01|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 6.1576438692e-01 1.5552264182e+01        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 6.1576438692e-01 - 1.0000000000e-05*1.5552264182e+01 = 6.1560886428e-01
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*1.5552264182e+01 = 1.5552108660e+01

Removing from the filter the redundant point:
  f_with_boundary     = 2.1813890002e+00
  theta_with_boundary = 6.8471483083e+01
  iteration added     = 0

(2) 1: "EvalNewPoint"

||x_k||inf            = 4.6135478069e-01
||x(var_dep)_k||inf   = 7.4771752444e-03
||x(var_indep)_k||inf = 4.6135478069e-01

x(var_indep)_k = 
 5
  0.461355:1 0.461299:2 0.461299:3 0.461299:4 0.461244:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 6.1576438692e-01
||Gf_k||inf              = 4.6135478069e-01
||Gf_k(var_dep)_k||inf   = 7.4771752444e-03
||Gf_k(var_indep)_k||inf = 4.6135478069e-01
||c_k||inf               = 1.5830011682e+01

Gf(var_indep)_k =
 5
  0.461355:1 0.461299:2 0.461299:3 0.461299:4 0.461244:5

(2) 2: "QuasiNormalStep"

||py||   = 7.0350662441e-03

||Ypy||2 = 3.9705009790e-01

(2) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 4.4441320608e-04

(2) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 2.3092638912e-14 / (1.5830011682e+01 + 2.2250738585e-308)
     = 1.4587884946e-15

(2) 3: "ReducedGradient"

||rGf||inf = 4.1554627380e-01

rGf_k =
 5
  0.415546:1 0.415437:2 0.415437:3 0.415437:4 0.415329:5

(2) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(8.3732647964e-01+3.7503756046e+03))
        * (6.0331754008e-02/1.0621477516e+00)
      = 9.2741722769e-03
ratio < 1
Skipping BFGS update ...

rHL_k = rHL_km1

(2) 4: "ReducedHessian"

The matrix rHL_k has already been updated so leave it

(2) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -0.461345:1 -0.461289:2 -0.461289:3 -0.461289:4 -0.461234:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(2) 5: "TangentialStep"

qp_grad_k = 
 5
  0.415546:1 0.415437:2 0.415437:3 0.415437:4 0.415329:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 4.3200066153e-02

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 2.5101622321e-02
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+00
||Zpz_k||2     = 5.7849459762e-02

pz_k = 
 5
  -0.0251016:1 -0.0250955:2 -0.0250955:3 -0.0250955:4 -0.0250893:5

nu_k(var_indep) = 
 5
  0:1 0:2 0:3 0:4 0:5

Zpz(var_indep)_k = 
 5
  -0.0251016:1 -0.0250955:2 -0.0250955:3 -0.0250955:4 -0.0250893:5


(2) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-3.2656169435e-16)/(3.9705009790e-01 * 5.7849459762e-02 + 2.2250738585e-308)
  = -1.4217414516e-14

||d_k||inf            = 6.8289342521e-02
||d(var_dep)_k||inf   = 6.7783028666e-03
||d(var_indep)_k||inf = 6.8289342521e-02

d(var_indep)_k = 
 5
  -0.0682077:1 -0.0682485:2 -0.0682485:3 -0.0682485:4 -0.0682893:5

(2) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 4.1554627380e-01

rGL_k = 
 5
  0.415546:1 0.415437:2 0.415437:3 0.415437:4 0.415329:5

(2) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.4613547807e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.8435687164e-01 > opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 1.5830011682e+01 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = -0.0000000000e+00 < comp_tol = 1.0000000000e-06
step_err         = 4.6733716607e-02 > step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 2) :-(

(2) 9.-1: "LineSearchFullStep"

f_k        = 6.1576438692e-01
||c_k||inf = 1.5830011682e+01
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 3.9314710830e-01

f_kp1        = 3.8695300275e-01
||c_kp1||inf = 1.3445285133e+00

(2) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.5552264182e+01

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|         6.1560886428e-01          1.5552108660e+01|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 3.8695300275e-01 1.3201800917e+00        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 3.8695300275e-01 - 1.0000000000e-05*1.3201800917e+00 = 3.8693980095e-01
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*1.3201800917e+00 = 1.3201668899e+00

Removing from the filter the redundant point:
  f_with_boundary     = 6.1560886428e-01
  theta_with_boundary = 1.5552108660e+01
  iteration added     = 1

(3) 1: "EvalNewPoint"

||x_k||inf            = 3.9314710830e-01
||x(var_dep)_k||inf   = 6.9887237779e-04
||x(var_indep)_k||inf = 3.9314710830e-01

x(var_indep)_k = 
 5
  0.393147:1 0.393051:2 0.393051:3 0.393051:4 0.392954:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 3.8695300275e-01
||Gf_k||inf              = 3.9314710830e-01
||Gf_k(var_dep)_k||inf   = 6.9887237779e-04
||Gf_k(var_indep)_k||inf = 3.9314710830e-01
||c_k||inf               = 1.3445285133e+00

Gf(var_indep)_k =
 5
  0.393147:1 0.393051:2 0.393051:3 0.393051:4 0.392954:5

(3) 2: "QuasiNormalStep"

||py||   = 6.9845040071e-04

||Ypy||2 = 3.8222397636e-02

(3) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 5.1947607941e-04

(3) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 1.1102230246e-15 / (1.3445285133e+00 + 2.2250738585e-308)
     = 8.2573408721e-16

(3) 3: "ReducedGradient"

||rGf||inf = 3.9272839189e-01

rGf_k =
 5
  0.392728:1 0.392631:2 0.392631:3 0.392631:4 0.392533:5

(3) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(9.2894644415e-01+8.5183273306e+02))
        * (5.7849459762e-02/3.9705009790e-01)
      = 4.9893062465e-02
ratio < 1
Skipping BFGS update ...

rHL_k = rHL_km1

(3) 4: "ReducedHessian"

The matrix rHL_k has already been updated so leave it

(3) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -0.393137:1 -0.393041:2 -0.393041:3 -0.393041:4 -0.392944:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(3) 5: "TangentialStep"

qp_grad_k = 
 5
  0.392728:1 0.392631:2 0.392631:3 0.392631:4 0.392533:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 4.2053082371e-04

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 2.3723277979e-02
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+00
||Zpz_k||2     = 5.3050520400e-02

pz_k = 
 5
  -0.0237233:1 -0.0237178:2 -0.0237178:3 -0.0237178:4 -0.0237123:5

nu_k(var_indep) = 
 5
  0:1 0:2 0:3 0:4 0:5

Zpz(var_indep)_k = 
 5
  -0.0237233:1 -0.0237178:2 -0.0237178:3 -0.0237178:4 -0.0237123:5


(3) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-9.2326591251e-19)/(3.8222397636e-02 * 5.3050520400e-02 + 2.2250738585e-308)
  = -4.5532262059e-16

||d_k||inf            = 2.4141742846e-02
||d(var_dep)_k||inf   = 6.7465659398e-04
||d(var_indep)_k||inf = 2.4141742846e-02

d(var_indep)_k = 
 5
  -0.0241417:1 -0.0241373:2 -0.0241373:3 -0.0241373:4 -0.0241328:5

(3) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 3.9272839189e-01

rGL_k = 
 5
  0.392728:1 0.392631:2 0.392631:3 0.392631:4 0.392533:5

(3) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.3931471083e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.8190015939e-01 > opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 1.3445285133e+00 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = -0.0000000000e+00 < comp_tol = 1.0000000000e-06
step_err         = 1.7328925784e-02 > step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 3) :-(

(3) 9.-1: "LineSearchFullStep"

f_k        = 3.8695300275e-01
||c_k||inf = 1.3445285133e+00
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 3.6900536545e-01

f_kp1        = 3.4024364074e-01
||c_kp1||inf = 4.4987367193e-02

(3) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.3201800917e+00

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|         3.8693980095e-01          1.3201668899e+00|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 3.4024364074e-01 4.4177631526e-02        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 3.4024364074e-01 - 1.0000000000e-05*4.4177631526e-02 = 3.4024319897e-01
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*4.4177631526e-02 = 4.4177189749e-02

Removing from the filter the redundant point:
  f_with_boundary     = 3.8693980095e-01
  theta_with_boundary = 1.3201668899e+00
  iteration added     = 2

(4) 1: "EvalNewPoint"

||x_k||inf            = 3.6900536545e-01
||x(var_dep)_k||inf   = 2.4215783810e-05
||x(var_indep)_k||inf = 3.6900536545e-01

x(var_indep)_k = 
 5
  0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 3.4024364074e-01
||Gf_k||inf              = 3.6900536545e-01
||Gf_k(var_dep)_k||inf   = 2.4215783810e-05
||Gf_k(var_indep)_k||inf = 3.6900536545e-01
||c_k||inf               = 4.4987367193e-02

Gf(var_indep)_k =
 5
  0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

(4) 2: "QuasiNormalStep"

||py||   = 2.4215765620e-05

||Ypy||2 = 1.3249505872e-03

(4) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 5.3827923550e-04

(4) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 4.1633363423e-17 / (4.4987367193e-02 + 2.2250738585e-308)
     = 9.2544565333e-16

(4) 3: "ReducedGradient"

||rGf||inf = 3.6900485363e-01

rGf_k =
 5
  0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

(4) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(8.7794944328e-01+7.2309266475e+01))
        * (5.3050520400e-02/3.8222397636e-02)
      = 1.6223856969e+00
ratio > 1
Perform BFGS update if you can ...

(4) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 2.3723538254e-02

||s_bfgs||inf = 2.3723277979e-02

y_bfgs =
 5
  -0.0237235:1 -0.023718:2 -0.023718:3 -0.023718:4 -0.0237125:5

s_bfgs =
 5
  -0.0237233:1 -0.0237178:2 -0.0237178:3 -0.0237178:4 -0.0237123:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 2.8126935606e-03 <  s_bfgs' * B * s_bfgs = 4.6561647149e-02
Dampen the update ...
theta = 8.5143334100e-01
y_bfgs = theta*y_bfgs + (1-theta)*B*s_bfgs ...
||y_bfgs||inf = 7.8545356511e-02
y_bfgs =
 5
  -0.0785454:1 -0.0785262:2 -0.0785262:3 -0.0785262:4 -0.078507:5

B after the BFGS update = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   13.9044:1:1 0:1:2 4.0687:1:3 2.85463e-09:1:4 1.95474e-09:1:5
   -2.64929:2:1 13.9056:2:2 0:2:3 4.0687:2:4 1.05485e-09:2:5
   -2.64929:3:1 -2.64869:3:2 13.9056:3:3 0:3:4 4.0687:3:5
   -2.64929:4:1 -2.64869:4:2 -2.64869:4:3 13.9056:4:4 0:4:5
   -2.64869:5:1 -2.64808:5:2 -2.64808:5:3 -2.64808:5:4 13.9068:5:5

||rHL_k||inf    = 2.4499747866e+01

cond_inf(rHL_k) = 7.4011738690e+00

rHL_k = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   13.9044:1:1 0:1:2 3.66071:1:3 -0.861437:1:4 -0.861437:1:5
   -2.64929:2:1 13.9056:2:2 0:2:3 3.55791:2:4 -1.0949:2:5
   -2.64929:3:1 -2.64869:3:2 13.9056:3:3 0:3:4 3.38525:3:5
   -2.64929:4:1 -2.64869:4:2 -2.64869:4:3 13.9056:4:4 0:4:5
   -2.64869:5:1 -2.64808:5:2 -2.64808:5:3 -2.64808:5:4 13.9068:5:5
 Matrix scaling M = scale*U'*U, scale = 1
 Upper cholesky factor U (ignore lower nonzeros):
  5 5
   3.72886:1:1 -0.710484:1:2 -0.710484:1:3 -0.710484:1:4 -0.710321:1:5
   0:2:1 3.66071:2:2 -0.861437:2:3 -0.861437:2:4 -0.86124:2:5
   13.9056:3:1 0:3:2 3.55791:3:3 -1.0949:3:4 -1.09465:3:5
   -2.64869:4:1 13.9056:4:2 0:4:3 3.38525:4:4 -1.50452:4:5
   -2.64869:5:1 -2.64869:5:2 13.9056:5:3 0:5:4 3.03294:5:5

(4) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -0.368995:1 -0.368903:2 -0.368903:3 -0.368903:4 -0.368811:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(4) 5: "TangentialStep"

qp_grad_k = 
 5
  0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 5.1410422885e-07

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 1.1145113136e-01
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+00
||Zpz_k||2     = 2.4915426691e-01

pz_k = 
 5
  -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5

nu_k(var_indep) = 
 5
  0:1 0:2 0:3 0:4 0:5

Zpz(var_indep)_k = 
 5
  -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5


(4) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-1.0164395367e-20)/(1.3249505872e-03 * 2.4915426691e-01 + 2.2250738585e-308)
  = -3.0790272924e-17

||d_k||inf            = 1.1145164318e-01
||d(var_dep)_k||inf   = 2.0274247521e-05
||d(var_indep)_k||inf = 1.1145164318e-01

d(var_indep)_k = 
 5
  -0.111452:1 -0.111426:2 -0.111426:3 -0.111426:4 -0.1114:5

(4) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 3.6900485363e-01

rGL_k = 
 5
  0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

(4) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.3690053654e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.6954229906e-01 > opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 4.4987367193e-02 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = -0.0000000000e+00 < comp_tol = 1.0000000000e-06
step_err         = 8.1410669372e-02 > step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 4) :-(

(4) 9.-1: "LineSearchFullStep"

f_k        = 3.4024364074e-01
||c_k||inf = 4.4987367193e-02
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 2.5755372227e-01

f_kp1        = 1.6574989579e-01
||c_kp1||inf = 6.1791102848e-03

(4) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 4.4177631526e-02

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|         3.4024319897e-01          4.4177189749e-02|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 1.6574989579e-01 6.0687208500e-03        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 1.6574989579e-01 - 1.0000000000e-05*6.0687208500e-03 = 1.6574983511e-01
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*6.0687208500e-03 = 6.0686601628e-03

Removing from the filter the redundant point:
  f_with_boundary     = 3.4024319897e-01
  theta_with_boundary = 4.4177189749e-02
  iteration added     = 3

(5) 1: "EvalNewPoint"

||x_k||inf            = 2.5755372227e-01
||x(var_dep)_k||inf   = 3.9415362886e-06
||x(var_indep)_k||inf = 2.5755372227e-01

x(var_indep)_k = 
 5
  0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 1.6574989579e-01
||Gf_k||inf              = 2.5755372227e-01
||Gf_k(var_dep)_k||inf   = 3.9415362886e-06
||Gf_k(var_indep)_k||inf = 2.5755372227e-01
||c_k||inf               = 6.1791102848e-03

Gf(var_indep)_k =
 5
  0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

(5) 2: "QuasiNormalStep"

||py||   = 3.9415361956e-06

||Ypy||2 = 2.1569444240e-04

(5) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 6.3788086213e-04

(5) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 6.0715321659e-18 / (6.1791102848e-03 + 2.2250738585e-308)
     = 9.8259003094e-16

(5) 3: "ReducedGradient"

||rGf||inf = 2.5755370750e-01

rGf_k =
 5
  0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

(5) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(8.2491431895e-01+2.4197092553e+00))
        * (2.4915426691e-01/1.3249505872e-03)
      = 1.0439663191e+03
ratio > 1
Perform BFGS update if you can ...

(5) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 1.1145114613e-01

||s_bfgs||inf = 1.1145113136e-01

y_bfgs =
 5
  -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5

s_bfgs =
 5
  -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 6.2077810439e-02 >=  s_bfgs' * B * s_bfgs = 2.0553084537e-01
Perform the undamped update ...

B after the BFGS update = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   13.442:1:1 0:1:2 3.66071:1:3 -0.861437:1:4 -0.861437:1:5
   -3.11158:2:1 13.4434:2:2 0:2:3 3.55791:2:4 -1.0949:2:5
   -3.11158:3:1 -3.11086:3:2 13.4434:3:3 0:3:4 3.38525:3:5
   -3.11158:4:1 -3.11086:4:2 -3.11086:4:3 13.4434:4:4 0:4:5
   -3.11086:5:1 -3.11013:5:2 -3.11013:5:3 -3.11013:5:4 13.4449:5:5

||rHL_k||inf    = 2.5886144627e+01

cond_inf(rHL_k) = 2.5891815803e+01

rHL_k = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   13.442:1:1 0:1:2 3.56695:1:3 -1.07406:1:4 -1.07406:1:5
   -3.11158:2:1 13.4434:2:2 0:2:3 3.4014:2:4 -1.4655:2:5
   -3.11158:3:1 -3.11086:3:2 13.4434:3:3 0:3:4 3.0695:3:5
   -3.11158:4:1 -3.11086:4:2 -3.11086:4:3 13.4434:4:4 0:4:5
   -3.11086:5:1 -3.11013:5:2 -3.11013:5:3 -3.11013:5:4 13.4449:5:5
 Matrix scaling M = scale*U'*U, scale = 1
 Upper cholesky factor U (ignore lower nonzeros):
  5 5
   3.66633:1:1 -0.848692:1:2 -0.848692:1:3 -0.848692:1:4 -0.848494:1:5
   0:2:1 3.56695:2:2 -1.07406:2:3 -1.07406:2:4 -1.07381:2:5
   13.4434:3:1 0:3:2 3.4014:3:3 -1.4655:3:4 -1.46516:3:5
   -3.11086:4:1 13.4434:4:2 0:4:3 3.0695:4:4 -2.3231:4:5
   -3.11086:5:1 -3.11086:5:2 13.4434:5:3 0:5:4 2.00709:5:5

(5) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -0.257544:1 -0.257478:2 -0.257478:3 -0.257478:4 -0.257412:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(5) 5: "TangentialStep"

qp_grad_k = 
 5
  0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 1.4826932622e-08

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 2.5753641905e-01
nu_k.nz()      = 1
max(|nu_k(i)|) = 6.2413617790e-05
||Zpz_k||2     = 5.7573213689e-01

pz_k = 
 5
  -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

nu_k(var_indep) = 
 5
  0:1 0:2 0:3 0:4 -6.24136e-05:5

Zpz(var_indep)_k = 
 5
  -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5


(5) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (4.9217246447e-22)/(2.1569444240e-04 * 5.7573213689e-01 + 2.2250738585e-308)
  = 3.9633085606e-18

||d_k||inf            = 2.5753643382e-01
||d(var_dep)_k||inf   = 2.3277613186e-06
||d(var_indep)_k||inf = 2.5753643382e-01

d(var_indep)_k = 
 5
  -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

(5) 7: "CalcReducedGradLagrangian"

rGL_k = 
 5
  0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257359:5

||rGL_k||inf = 2.5755370750e-01

rGL_k = 
 5
  0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257359:5

(5) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.2575537223e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.0480533192e-01 > opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 6.1791102848e-03 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = 1.6066000963e-05 > comp_tol = 1.0000000000e-06
step_err         = 2.0479159598e-01 > step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 5) :-(

(5) 9.-1: "LineSearchFullStep"

f_k        = 1.6574989579e-01
||c_k||inf = 6.1791102848e-03
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 1.7288455117e-05

f_kp1        = 4.3078479209e-09
||c_kp1||inf = 1.6001110173e-03

(5) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 6.0687208500e-03

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|         1.6574983511e-01          6.0686601628e-03|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 4.3078479209e-09 1.5716730031e-03        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 4.3078479209e-09 - 1.0000000000e-05*1.5716730031e-03 = -1.1408882110e-08
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*1.5716730031e-03 = 1.5716572864e-03

Removing from the filter the redundant point:
  f_with_boundary     = 1.6574983511e-01
  theta_with_boundary = 6.0686601628e-03
  iteration added     = 4

(6) 1: "EvalNewPoint"

||x_k||inf            = 1.7288455117e-05
||x(var_dep)_k||inf   = 1.6137749700e-06
||x(var_indep)_k||inf = 1.7288455117e-05

x(var_indep)_k = 
 5
  1.72885e-05:1 1.17603e-05:2 1.176e-05:3 1.17596e-05:4 1e-05:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 4.3078479209e-09
||Gf_k||inf              = 1.7288455117e-05
||Gf_k(var_dep)_k||inf   = 1.6137749700e-06
||Gf_k(var_indep)_k||inf = 1.7288455117e-05
||c_k||inf               = 1.6001110173e-03

Gf(var_indep)_k =
 5
  1.72885e-05:1 1.17603e-05:2 1.176e-05:3 1.17596e-05:4 1e-05:5

(6) 2: "QuasiNormalStep"

||py||   = 1.6137749599e-06

||Ypy||2 = 8.8328450816e-05

(6) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 1.0085393716e-03

(6) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 1.3010426070e-18 / (1.6001110173e-03 + 2.2250738585e-308)
     = 8.1309521210e-16

(6) 3: "ReducedGradient"

||rGf||inf = 1.7285338958e-05

rGf_k =
 5
  1.72853e-05:1 1.17572e-05:2 1.17568e-05:3 1.17565e-05:4 9.99687e-06:5

(6) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(5.7573220998e-01+3.3239761380e-01))
        * (5.7573213689e-01/2.1569444240e-04)
      = 2.8009641333e+04
ratio > 1
Perform BFGS update if you can ...

(6) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 2.5753642216e-01

||s_bfgs||inf = 2.5753641905e-01

y_bfgs =
 5
  -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

s_bfgs =
 5
  -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 3.3146748967e-01 >=  s_bfgs' * B * s_bfgs = 3.3146752990e-01
Perform the undamped update ...

B after the BFGS update = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   13.442:1:1 0:1:2 3.56695:1:3 -1.07406:1:4 -1.07406:1:5
   -3.11161:2:1 13.4434:2:2 0:2:3 3.4014:2:4 -1.4655:2:5
   -3.11161:3:1 -3.11088:3:2 13.4434:3:3 0:3:4 3.0695:3:5
   -3.11161:4:1 -3.11088:4:2 -3.11088:4:3 13.4434:4:4 0:4:5
   -3.11083:5:1 -3.1101:5:2 -3.1101:5:3 -3.1101:5:4 13.445:5:5

||rHL_k||inf    = 2.5886103889e+01

cond_inf(rHL_k) = 2.5891882950e+01

rHL_k = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   13.442:1:1 0:1:2 3.56695:1:3 -1.07407:1:4 -1.07407:1:5
   -3.11161:2:1 13.4434:2:2 0:2:3 3.4014:2:4 -1.46552:2:5
   -3.11161:3:1 -3.11088:3:2 13.4434:3:3 0:3:4 3.06949:3:5
   -3.11161:4:1 -3.11088:4:2 -3.11088:4:3 13.4434:4:4 0:4:5
   -3.11083:5:1 -3.1101:5:2 -3.1101:5:3 -3.1101:5:4 13.445:5:5
 Matrix scaling M = scale*U'*U, scale = 1
 Upper cholesky factor U (ignore lower nonzeros):
  5 5
   3.66633:1:1 -0.848699:1:2 -0.848699:1:3 -0.848699:1:4 -0.848487:1:5
   0:2:1 3.56695:2:2 -1.07407:2:3 -1.07407:2:4 -1.07381:2:5
   13.4434:3:1 0:3:2 3.4014:3:3 -1.46552:3:4 -1.46515:3:5
   -3.11088:4:1 13.4434:4:2 0:4:3 3.06949:4:4 -2.32311:4:5
   -3.11088:5:1 -3.11088:5:2 13.4434:5:3 0:5:4 2.0071:5:5

(6) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -7.28846e-06:1 -1.76034e-06:2 -1.75996e-06:3 -1.75958e-06:4 -1.00001e-17:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(6) 5: "TangentialStep"

qp_grad_k = 
 5
  1.72853e-05:1 1.17572e-05:2 1.17568e-05:3 1.17565e-05:4 9.99687e-06:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 3.1252363232e-09

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 2.5052443219e-06
nu_k.nz()      = 4
max(|nu_k(i)|) = 3.4224117743e-05
||Zpz_k||2     = 3.9415350433e-06

pz_k = 
 5
  -2.50524e-06:1 -1.75722e-06:2 -1.75684e-06:3 -1.75645e-06:4 3.12524e-09:5

nu_k(var_indep) = 
 5
  0:1 -6.8492e-06:2 -6.85516e-06:3 -6.86113e-06:4 -3.42241e-05:5

Zpz(var_indep)_k = 
 5
  -2.50524e-06:1 -1.75722e-06:2 -1.75684e-06:3 -1.75645e-06:4 3.12524e-09:5


(6) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (1.7579272235e-28)/(8.8328450816e-05 * 3.9415350433e-06 + 2.2250738585e-308)
  = 5.0493431509e-19

||d_k||inf            = 2.5083604808e-06
||d(var_dep)_k||inf   = 1.6137749700e-06
||d(var_indep)_k||inf = 2.5083604808e-06

d(var_indep)_k = 
 5
  -2.50836e-06:1 -1.76034e-06:2 -1.75996e-06:3 -1.75958e-06:4 -1.00001e-17:5

(6) 7: "CalcReducedGradLagrangian"

rGL_k = 
 5
  1.72853e-05:1 4.90802e-06:2 4.90168e-06:3 4.89533e-06:4 -2.42272e-05:5

||rGL_k||inf = 2.4227242979e-05

rGL_k = 
 5
  1.72853e-05:1 4.90802e-06:2 4.90168e-06:3 4.89533e-06:4 -2.42272e-05:5

(6) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.0000172885e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.4226824135e-05 < opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 1.6001110173e-03 > feas_tol = 1.0000000000e-07
comp_kkt_err_k   = 1.2072668757e-11 < comp_tol = 1.0000000000e-06
step_err         = 2.5083171159e-06 < step_tol = 1.0000000000e-02

Have not found the solution yet, have to keep going (k = 6) :-(

(6) 9.-1: "LineSearchFullStep"

f_k        = 4.3078479209e-09
||c_k||inf = 1.6001110173e-03
alpha_k    = 1.0000000000e+00

||x_kp1||inf   = 1.4780094636e-05

f_kp1        = 3.0922559878e-10
||c_kp1||inf = 7.9473675342e-09

(6) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.5716730031e-03

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-05.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|        -1.1408882110e-08          1.5716572864e-03|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+00 3.0922559878e-10 4.8949810733e-09        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 3.0922559878e-10 - 1.0000000000e-05*4.8949810733e-09 = 3.0917664897e-10
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-05)*4.8949810733e-09 = 4.8949321235e-09

(7) 1: "EvalNewPoint"

||x_k||inf            = 1.4780094636e-05
||x(var_dep)_k||inf   = 8.0843549147e-12
||x(var_indep)_k||inf = 1.4780094636e-05

x(var_indep)_k = 
 5
  1.47801e-05:1 1e-05:2 1e-05:3 1e-05:4 1e-05:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 3.0922559878e-10
||Gf_k||inf              = 1.4780094636e-05
||Gf_k(var_dep)_k||inf   = 8.0843549147e-12
||Gf_k(var_indep)_k||inf = 1.4780094636e-05
||c_k||inf               = 7.9473675342e-09

Gf(var_indep)_k =
 5
  1.47801e-05:1 1e-05:2 1e-05:3 1e-05:4 1e-05:5

(7) 2: "QuasiNormalStep"

||py||   = 8.0843549147e-12

||Ypy||2 = 3.1177993328e-10

(7) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 1.0172368246e-03

(7) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 6.6174449004e-24 / (7.9473675342e-09 + 2.2250738585e-308)
     = 8.3265872278e-16

(7) 3: "ReducedGradient"

||rGf||inf = 1.4780094636e-05

rGf_k =
 5
  1.47801e-05:1 1e-05:2 1e-05:3 1e-05:4 1e-05:5

(7) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+01/sqrt(3.0948692946e-05+8.6084094835e-02))
        * (3.9415350433e-06/8.8328450816e-05)
      = 1.5206359932e+00
ratio > 1
Perform BFGS update if you can ...

(7) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 2.5052443219e-06

||s_bfgs||inf = 2.5052443219e-06

y_bfgs =
 5
  -2.50524e-06:1 -1.75722e-06:2 -1.75684e-06:3 -1.75645e-06:4 3.12524e-09:5

s_bfgs =
 5
  -2.50524e-06:1 -1.75722e-06:2 -1.75684e-06:3 -1.75645e-06:4 3.12524e-09:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 1.5535698401e-11 >=  s_bfgs' * B * s_bfgs = 6.9214067476e-11
Perform the undamped update ...

B after the BFGS update = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   9.52915:1:1 0:1:2 3.56695:1:3 -1.07407:1:4 -1.07407:1:5
   -4.05396:2:1 13.2941:2:2 0:2:3 3.4014:2:4 -1.46552:2:5
   -4.05244:3:1 -3.25975:3:2 13.295:3:3 0:3:4 3.06949:3:5
   -4.05091:4:1 -3.25934:4:2 -3.25893:4:3 13.2958:4:4 0:4:5
   2.93911:5:1 -1.39248:5:2 -1.3947:5:3 -1.39693:5:4 4.96462:5:5

||rHL_k||inf    = 2.4625571263e+01

cond_inf(rHL_k) = 3.1556895452e+01

rHL_k = 
 Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
  5 5
   9.52915:1:1 0:1:2 3.40139:1:3 -1.46521:1:4 -1.4649:1:5
   -4.05396:2:1 13.2941:2:2 0:2:3 3.06997:2:4 -2.32186:2:5
   -4.05244:3:1 -3.25975:3:2 13.295:3:3 0:3:4 2.00916:3:5
   -4.05091:4:1 -3.25934:4:2 -3.25893:4:3 13.2958:4:4 0:4:5
   2.93911:5:1 -1.39248:5:2 -1.3947:5:3 -1.39693:5:4 4.96462:5:5
 Matrix scaling M = scale*U'*U, scale = 1
 Upper cholesky factor U (ignore lower nonzeros):
  5 5
   3.08693:1:1 -1.31326:1:2 -1.31277:1:3 -1.31228:1:4 0.952114:1:5
   0:2:1 3.40139:2:2 -1.46521:2:3 -1.4649:2:4 -0.0417781:2:5
   13.2941:3:1 0:3:2 3.06997:3:3 -2.32186:3:4 -0.0671046:3:5
   -3.25975:4:1 13.295:4:2 0:4:3 2.00916:4:4 -0.181417:4:5
   -3.25934:5:1 -3.25893:5:2 13.2958:5:3 0:5:4 2.00473:5:5

(7) 5.-1: "SetDBoundsStd"

dl(var_indep)_k = 
 5
  -4.78009e-06:1 0:2 0:3 0:4 0:5

du(var_indep)_k = 
 5
  1e+50:1 1e+50:2 1e+50:3 1e+50:4 1e+50:5

(7) 5: "TangentialStep"

qp_grad_k = 
 5
  1.47801e-05:1 1e-05:2 1e-05:3 1e-05:4 1e-05:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 0xe2c76b0
    ||Ypy_k(var_indep)||inf = 7.8420208892e-20

Using simple bounds on pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

Calling QPKWIK to solve QP problem ...

||pz_k||inf    = 1.5510400571e-06
nu_k.nz()      = 4
max(|nu_k(i)|) = 1.6287853297e-05
||Zpz_k||2     = 1.5510400571e-06

pz_k = 
 5
  -1.55104e-06:1 3.86837e-20:2 3.86646e-20:3 3.86426e-20:4 4.74479e-35:5

nu_k(var_indep) = 
 5
  0:1 -1.62879e-05:2 -1.62855e-05:3 -1.62831e-05:4 -5.44132e-06:5

Zpz(var_indep)_k = 
 5
  -1.55104e-06:1 3.86837e-20:2 3.86646e-20:3 3.86426e-20:4 4.74479e-35:5


(7) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-3.6810718738e-39)/(3.1177993328e-10 * 1.5510400571e-06 + 2.2250738585e-308)
  = -7.6120761359e-24

||d_k||inf            = 1.5510400571e-06
||d(var_dep)_k||inf   = 8.0843298368e-12
||d(var_indep)_k||inf = 1.5510400571e-06

d(var_indep)_k = 
 5
  -1.55104e-06:1 0:2 0:3 0:4 0:5

(7) 7: "CalcReducedGradLagrangian"

rGL_k = 
 5
  1.47801e-05:1 -6.28785e-06:2 -6.28549e-06:3 -6.28313e-06:4 4.55868e-06:5

||rGL_k||inf = 1.4780094636e-05

rGL_k = 
 5
  1.47801e-05:1 -6.28785e-06:2 -6.28549e-06:3 -6.28313e-06:4 4.55868e-06:5

(7) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+00 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+00 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+00 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.0000147801e+00 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 1.4779876188e-05 < opt_tol  = 1.0000000000e-02
feas_kkt_err_k   = 7.9473675342e-09 < feas_tol = 1.0000000000e-07
comp_kkt_err_k   = 0.0000000000e+00 < comp_tol = 1.0000000000e-06
step_err         = 1.5510171329e-06 < step_tol = 1.0000000000e-02

Jackpot!  Found the solution!!!!!! (k = 7)
